{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>The package parameterspace is used to define parameter spaces consisting of mixed types (continuous, integer, categorical) with conditionalities and priors. It allows for easy specification of the parameters and their dependencies.</p> <p>The <code>ParameterSpace</code> object can then be used to sample random configurations from the prior and convert any valid configuration into a numerical representation. This numerical representation has the following properties:</p> <ul> <li>it results in a numpy <code>ndarray</code> of type <code>numpy.float64</code></li> <li>transformed representation between 0 and 1 (uniform) including integers, ordinal and   categorical parameters</li> <li>inactive parameters are masked as <code>numpy.nan</code> values</li> </ul> <p>This allows to easily use optimizers that expect continuous domains to be used on more complicated problems because <code>ParameterSpace</code> can convert any numerical vector representation inside the unit hypercube into a valid configuration. The function might not be smooth, but for robust methods (like genetic algorithms/evolutionary strategies) this might still be valuable.</p> <p>The package can be installed from PyPi with:</p> <pre><code>pip install parameterspace\n</code></pre>"},{"location":"#configspace-compatibility","title":"ConfigSpace Compatibility","text":"<p>In case you are used to working with ConfigSpace or for other reasons have space definitions in the <code>ConfigSpace</code> format around, you can convert them into <code>ParameterSpace</code> instances with ease. Just note that any colons <code>:</code> in the <code>ConfigSpace</code> parameter names will be converted to underscores <code>_</code>.</p> <pre><code>import json\nfrom parameterspace.configspace_utils import parameterspace_from_configspace_dict\n\nwith open(\"config_space.json\", \"r\") as fh:\n  cs = json.load(fh)\n\nps = parameterspace_from_configspace_dict(cs)\n</code></pre>"},{"location":"generate_references/","title":"Generate references","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate \"virtual\" doc files for the api references.\n\nThe files are only generated during build time and not actually written on disk.\nTo write them on disk (for e.g. debugging) execute this script directely.\n\"\"\"\nfrom pathlib import Path\n</pre> \"\"\"Generate \"virtual\" doc files for the api references.  The files are only generated during build time and not actually written on disk. To write them on disk (for e.g. debugging) execute this script directely. \"\"\" from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre># Files to exclude from the generated API docs\nexcludes = [\"__init__\"]\n</pre> # Files to exclude from the generated API docs excludes = [\"__init__\"] In\u00a0[\u00a0]: Copied! <pre>src_root = Path(\"parameterspace\")\nfor path in src_root.glob(\"**/*.py\"):\n    doc_path = Path(\"API-Reference\", path.relative_to(src_root)).with_suffix(\".md\")\n\n    if any(exclude in str(doc_path) for exclude in excludes):\n        continue\n\n    with mkdocs_gen_files.open(doc_path, \"w\") as f:\n        ident = \".\".join(path.with_suffix(\"\").parts)\n        print(\"::: \" + ident, file=f)\n</pre> src_root = Path(\"parameterspace\") for path in src_root.glob(\"**/*.py\"):     doc_path = Path(\"API-Reference\", path.relative_to(src_root)).with_suffix(\".md\")      if any(exclude in str(doc_path) for exclude in excludes):         continue      with mkdocs_gen_files.open(doc_path, \"w\") as f:         ident = \".\".join(path.with_suffix(\"\").parts)         print(\"::: \" + ident, file=f)"},{"location":"API-Reference/base/","title":"Base","text":""},{"location":"API-Reference/base/#parameterspace.base.SearchSpace","title":"<code> SearchSpace            (ABC)         </code>","text":"<p>Abstract base class for different search space implementations.</p> Source code in <code>parameterspace/base.py</code> <pre><code>class SearchSpace(abc.ABC):\n    \"\"\"Abstract base class for different search space implementations.\"\"\"\n\n    def __init__(self, seed: int = None) -&gt; None:\n        \"\"\"Initialize a search space with an optional seed.\"\"\"\n        self.seed(seed)\n\n    @abc.abstractmethod\n    def __len__(self) -&gt; int:\n        \"\"\"The number of parameters in the space.\"\"\"\n\n    @abc.abstractmethod\n    def seed(self, seed: int) -&gt; None:\n        \"\"\"Reinitialize the random number generator with a new seed.\"\"\"\n\n    @abc.abstractmethod\n    def copy(self):\n        \"\"\"Get a copy that behaves exactly like the original `SearchSpace`.\n        Call `seed()` on the copy to get independent samples.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sample(self) -&gt; dict:\n        \"\"\"Provide a dictionary with one key corresponding to each parameter name and\n        its value representing a sample for that parameter.\n        \"\"\"\n\n    @abc.abstractmethod\n    def to_numerical(self, configuration: dict) -&gt; np.ndarray:\n        \"\"\"Given a configuration from this space, create a numerical vector\n        representation.\n        The transformed representation needs to be between 0 and 1 (uniform), including\n        integers, ordinal and categoricals.\n        Inactive parameters have to be represented with `np.nan`\n        \"\"\"\n\n    @abc.abstractmethod\n    def from_numerical(self, vector: np.ndarray) -&gt; dict:\n        \"\"\"Convert a np.float64 type vector numerical representation of a configuration\n        from this space to a dictionary representation.\"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.__init__","title":"<code>__init__(self, seed=None)</code>  <code>special</code>","text":"<p>Initialize a search space with an optional seed.</p> Source code in <code>parameterspace/base.py</code> <pre><code>def __init__(self, seed: int = None) -&gt; None:\n    \"\"\"Initialize a search space with an optional seed.\"\"\"\n    self.seed(seed)\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.__len__","title":"<code>__len__(self)</code>  <code>special</code>","text":"<p>The number of parameters in the space.</p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef __len__(self) -&gt; int:\n    \"\"\"The number of parameters in the space.\"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.copy","title":"<code>copy(self)</code>","text":"<p>Get a copy that behaves exactly like the original <code>SearchSpace</code>. Call <code>seed()</code> on the copy to get independent samples.</p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef copy(self):\n    \"\"\"Get a copy that behaves exactly like the original `SearchSpace`.\n    Call `seed()` on the copy to get independent samples.\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.from_numerical","title":"<code>from_numerical(self, vector)</code>","text":"<p>Convert a np.float64 type vector numerical representation of a configuration from this space to a dictionary representation.</p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef from_numerical(self, vector: np.ndarray) -&gt; dict:\n    \"\"\"Convert a np.float64 type vector numerical representation of a configuration\n    from this space to a dictionary representation.\"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.sample","title":"<code>sample(self)</code>","text":"<p>Provide a dictionary with one key corresponding to each parameter name and its value representing a sample for that parameter.</p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef sample(self) -&gt; dict:\n    \"\"\"Provide a dictionary with one key corresponding to each parameter name and\n    its value representing a sample for that parameter.\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.seed","title":"<code>seed(self, seed)</code>","text":"<p>Reinitialize the random number generator with a new seed.</p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef seed(self, seed: int) -&gt; None:\n    \"\"\"Reinitialize the random number generator with a new seed.\"\"\"\n</code></pre>"},{"location":"API-Reference/base/#parameterspace.base.SearchSpace.to_numerical","title":"<code>to_numerical(self, configuration)</code>","text":"<p>Given a configuration from this space, create a numerical vector representation. The transformed representation needs to be between 0 and 1 (uniform), including integers, ordinal and categoricals. Inactive parameters have to be represented with <code>np.nan</code></p> Source code in <code>parameterspace/base.py</code> <pre><code>@abc.abstractmethod\ndef to_numerical(self, configuration: dict) -&gt; np.ndarray:\n    \"\"\"Given a configuration from this space, create a numerical vector\n    representation.\n    The transformed representation needs to be between 0 and 1 (uniform), including\n    integers, ordinal and categoricals.\n    Inactive parameters have to be represented with `np.nan`\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/condition/","title":"Condition","text":""},{"location":"API-Reference/condition/#parameterspace.condition.Condition","title":"<code> Condition        </code>","text":"<p>Class that handels the logic of conditioning parameters on others in a ParameterSpace.</p> Source code in <code>parameterspace/condition.py</code> <pre><code>class Condition:\n    \"\"\"Class that handels the logic of conditioning parameters on others in a\n    ParameterSpace.\"\"\"\n\n    def __init__(self, lambda_fn: Callable = None):\n        \"\"\"\n        Args:\n            lambda_fn: A callable whose signature contains valid names of other\n                parameters. It returns True if the associate parameter is active,\n                and False otherwise.\n        \"\"\"\n        self.functions = []\n        self.function_texts = []\n        self.varnames = []\n        self.all_varnames = set()\n\n        if lambda_fn is not None:\n            self.functions = [lambda_fn]\n            varnames, function_text = utils.extract_lambda_information(\n                inspect.getsourcelines(lambda_fn)[0]\n            )\n            # self.varnames = [lambda_fn.__code__.co_varnames]\n            self.varnames = [varnames]\n            self.function_texts = [function_text]\n            self.all_varnames = set(lambda_fn.__code__.co_varnames)\n\n    def __repr__(self):\n        if not self.all_varnames:\n            return \"No conditions!\"\n        string = f\"Condition(s) depend(s) on {self.all_varnames}.\\n\"\n        string += \"\\n\".join(self.function_texts)\n        return string\n\n    def __call__(self, config=None):\n        if not self.all_varnames:\n            return True\n        config = {} if config is None else config\n        for vn, fn in zip(self.varnames, self.functions):\n            if not set(vn).issubset(config.keys()):\n                raise ValueError(\"Not all variables set to evaluate the condition!\")\n            args = [config[n] for n in vn]\n            if None in args:\n                return False\n            if not fn(*args):\n                return False\n        return True\n\n    def empty(self) -&gt; bool:\n        \"\"\"Check if this Condition is not trivial.\n\n        Returns:\n            [description]\n        \"\"\"\n        return not bool(self.all_varnames)\n\n    def merge(self, other: Condition = None) -&gt; Condition:\n        \"\"\"Concatenates two Conditions to allow for hierarchical spaces.\n\n        Args:\n            other: [description]\n\n        Returns:\n            [description]\n        \"\"\"\n        if other is not None:\n            self.all_varnames = self.all_varnames.union(other.all_varnames)\n            self.functions.extend(other.functions)\n            self.function_texts.extend(other.function_texts)\n            self.varnames.extend(other.varnames)\n        return self\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"[summary]\n\n        Returns:\n            [description]\n        \"\"\"\n        return_dict = {}\n        for i, (varnames, function_text) in enumerate(\n            zip(self.varnames, self.function_texts)\n        ):\n            return_dict[str(i)] = {\"varnames\": varnames, \"function_text\": function_text}\n        return return_dict\n\n    @staticmethod\n    def from_dict(\n        dict_representation: dict, verify_lambda: Callable = utils.verify_lambda\n    ) -&gt; Condition:\n        \"\"\"[summary]\n\n        Args:\n            dict_representation: [description]\n            verify_lambda: [description]\n\n        Raises:\n            RuntimeError: If \"function_text\" in in `dict_representation` is\n                not considered save.\n\n        Returns:\n            [description]\n        \"\"\"\n\n        return_condition = Condition()\n\n        for k in range(len(dict_representation)):\n            varnames = dict_representation[str(k)][\"varnames\"]\n            function_text = dict_representation[str(k)][\"function_text\"]\n\n            if not verify_lambda(varnames, function_text):\n                raise RuntimeError(f\"Source {function_text} is not considered save!\")\n\n            return_condition.function_texts.append(function_text)\n            return_condition.varnames.append(varnames)\n            return_condition.all_varnames |= set(varnames)\n\n            # pylint: disable=eval-used\n            return_condition.functions.append(\n                eval(f\"lambda {', '.join(varnames)}: {function_text}\")\n            )\n            # pylint: enable=eval-used\n\n        return return_condition\n\n    def __eq__(self, other):\n        if self.all_varnames != other.all_varnames:\n            return False\n        if len(self.function_texts) != len(other.function_texts):\n            return False\n\n        for t1, t2 in zip(self.function_texts, other.function_texts):\n            if t1 != t2:\n                return False\n\n        return True\n</code></pre>"},{"location":"API-Reference/condition/#parameterspace.condition.Condition.__init__","title":"<code>__init__(self, lambda_fn=None)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lambda_fn</code> <code>Callable</code> <p>A callable whose signature contains valid names of other parameters. It returns True if the associate parameter is active, and False otherwise.</p> <code>None</code> Source code in <code>parameterspace/condition.py</code> <pre><code>def __init__(self, lambda_fn: Callable = None):\n    \"\"\"\n    Args:\n        lambda_fn: A callable whose signature contains valid names of other\n            parameters. It returns True if the associate parameter is active,\n            and False otherwise.\n    \"\"\"\n    self.functions = []\n    self.function_texts = []\n    self.varnames = []\n    self.all_varnames = set()\n\n    if lambda_fn is not None:\n        self.functions = [lambda_fn]\n        varnames, function_text = utils.extract_lambda_information(\n            inspect.getsourcelines(lambda_fn)[0]\n        )\n        # self.varnames = [lambda_fn.__code__.co_varnames]\n        self.varnames = [varnames]\n        self.function_texts = [function_text]\n        self.all_varnames = set(lambda_fn.__code__.co_varnames)\n</code></pre>"},{"location":"API-Reference/condition/#parameterspace.condition.Condition.empty","title":"<code>empty(self)</code>","text":"<p>Check if this Condition is not trivial.</p> <p>Returns:</p> Type Description <code>bool</code> <p>[description]</p> Source code in <code>parameterspace/condition.py</code> <pre><code>def empty(self) -&gt; bool:\n    \"\"\"Check if this Condition is not trivial.\n\n    Returns:\n        [description]\n    \"\"\"\n    return not bool(self.all_varnames)\n</code></pre>"},{"location":"API-Reference/condition/#parameterspace.condition.Condition.from_dict","title":"<code>from_dict(dict_representation, verify_lambda=&lt;function verify_lambda at 0x7f481e23a160&gt;)</code>  <code>staticmethod</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>dict_representation</code> <code>dict</code> <p>[description]</p> required <code>verify_lambda</code> <code>Callable</code> <p>[description]</p> <code>&lt;function verify_lambda at 0x7f481e23a160&gt;</code> <p>Exceptions:</p> Type Description <code>RuntimeError</code> <p>If \"function_text\" in in <code>dict_representation</code> is not considered save.</p> <p>Returns:</p> Type Description <code>Condition</code> <p>[description]</p> Source code in <code>parameterspace/condition.py</code> <pre><code>@staticmethod\ndef from_dict(\n    dict_representation: dict, verify_lambda: Callable = utils.verify_lambda\n) -&gt; Condition:\n    \"\"\"[summary]\n\n    Args:\n        dict_representation: [description]\n        verify_lambda: [description]\n\n    Raises:\n        RuntimeError: If \"function_text\" in in `dict_representation` is\n            not considered save.\n\n    Returns:\n        [description]\n    \"\"\"\n\n    return_condition = Condition()\n\n    for k in range(len(dict_representation)):\n        varnames = dict_representation[str(k)][\"varnames\"]\n        function_text = dict_representation[str(k)][\"function_text\"]\n\n        if not verify_lambda(varnames, function_text):\n            raise RuntimeError(f\"Source {function_text} is not considered save!\")\n\n        return_condition.function_texts.append(function_text)\n        return_condition.varnames.append(varnames)\n        return_condition.all_varnames |= set(varnames)\n\n        # pylint: disable=eval-used\n        return_condition.functions.append(\n            eval(f\"lambda {', '.join(varnames)}: {function_text}\")\n        )\n        # pylint: enable=eval-used\n\n    return return_condition\n</code></pre>"},{"location":"API-Reference/condition/#parameterspace.condition.Condition.merge","title":"<code>merge(self, other=None)</code>","text":"<p>Concatenates two Conditions to allow for hierarchical spaces.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Condition</code> <p>[description]</p> <code>None</code> <p>Returns:</p> Type Description <code>Condition</code> <p>[description]</p> Source code in <code>parameterspace/condition.py</code> <pre><code>def merge(self, other: Condition = None) -&gt; Condition:\n    \"\"\"Concatenates two Conditions to allow for hierarchical spaces.\n\n    Args:\n        other: [description]\n\n    Returns:\n        [description]\n    \"\"\"\n    if other is not None:\n        self.all_varnames = self.all_varnames.union(other.all_varnames)\n        self.functions.extend(other.functions)\n        self.function_texts.extend(other.function_texts)\n        self.varnames.extend(other.varnames)\n    return self\n</code></pre>"},{"location":"API-Reference/condition/#parameterspace.condition.Condition.to_dict","title":"<code>to_dict(self)</code>","text":"<p>[summary]</p> <p>Returns:</p> Type Description <code>dict</code> <p>[description]</p> Source code in <code>parameterspace/condition.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"[summary]\n\n    Returns:\n        [description]\n    \"\"\"\n    return_dict = {}\n    for i, (varnames, function_text) in enumerate(\n        zip(self.varnames, self.function_texts)\n    ):\n        return_dict[str(i)] = {\"varnames\": varnames, \"function_text\": function_text}\n    return return_dict\n</code></pre>"},{"location":"API-Reference/configspace_utils/","title":"Configspace utils","text":"<p>Initialize a <code>ParameterSpace</code> from a <code>ConfigSpace</code> JSON dictionary.</p>"},{"location":"API-Reference/configspace_utils/#parameterspace.configspace_utils.parameterspace_from_configspace_dict","title":"<code>parameterspace_from_configspace_dict(configspace_dict)</code>","text":"<p>Create <code>ParameterSpace</code> instance from a <code>ConfigSpace</code> JSON dictionary.</p> <p>Note, that <code>ParameterSpace</code> does not support regular, non-truncated normal priors and will thus translate an unbounded normal prior to a normal truncated at +/- 4 sigma. Also, constant parameters are represented as categoricals with a single value that are fixed to said value.</p> <p>Parameters:</p> Name Type Description Default <code>configspace_dict</code> <code>dict</code> <p>The dictionary based on a <code>ConfigSpace</code> JSON representation.</p> required <p>Returns:</p> Type Description <code>Tuple[parameterspace.parameterspace.ParameterSpace, Dict[str, str]]</code> <p>A <code>ParameterSpace</code> instance. A mapping between parameter names that were changed for compatibility reasons.</p> Source code in <code>parameterspace/configspace_utils.py</code> <pre><code>def parameterspace_from_configspace_dict(\n    configspace_dict: dict,\n) -&gt; Tuple[ps.ParameterSpace, Dict[str, str]]:\n    \"\"\"Create `ParameterSpace` instance from a `ConfigSpace` JSON dictionary.\n\n    Note, that `ParameterSpace` does not support regular, non-truncated normal priors\n    and will thus translate an unbounded normal prior to a normal truncated at +/- 4\n    sigma. Also, constant parameters are represented as categoricals with a single value\n    that are fixed to said value.\n\n    Args:\n        configspace_dict: The dictionary based on a `ConfigSpace` JSON representation.\n\n    Returns:\n        A `ParameterSpace` instance.\n        A mapping between parameter names that were changed for compatibility reasons.\n\n    Raises:\n        NotImplementedError in case a given parameter type or configuration is not\n        supported.\n    \"\"\"\n    space = ps.ParameterSpace()\n    names: Dict[str, str] = {}\n\n    for param_dict in configspace_dict[\"hyperparameters\"]:\n        param_name = _escape_parameter_name(param_dict[\"name\"])\n        if param_dict[\"name\"] != param_name:\n            names[param_name] = param_dict[\"name\"]\n            names[param_dict[\"name\"]] = param_name\n\n        condition = _get_condition(configspace_dict[\"conditions\"], param_dict[\"name\"])\n        if param_dict[\"type\"] == \"uniform_int\":\n            space._parameters[param_name] = {\n                \"parameter\": ps.IntegerParameter(\n                    name=param_name,\n                    bounds=(param_dict[\"lower\"], param_dict[\"upper\"]),\n                    transformation=\"log\" if param_dict[\"log\"] else None,\n                ),\n                \"condition\": condition,\n            }\n\n        elif param_dict[\"type\"] == \"categorical\":\n            space._parameters[param_name] = {\n                \"parameter\": ps.CategoricalParameter(\n                    name=param_name,\n                    values=param_dict[\"choices\"],\n                    prior=param_dict.get(\"weights\", None),\n                ),\n                \"condition\": condition,\n            }\n\n        elif param_dict[\"type\"] in [\"constant\", \"unparametrized\"]:\n            space._parameters[param_name] = {\n                \"parameter\": ps.CategoricalParameter(\n                    name=param_name,\n                    values=[param_dict[\"value\"]],\n                ),\n                \"condition\": condition,\n            }\n            space.fix(**{param_name: param_dict[\"value\"]})\n\n        elif param_dict[\"type\"] in [\"normal_float\", \"normal_int\"]:\n            parameter_class = (\n                ps.ContinuousParameter\n                if param_dict[\"type\"] == \"normal_float\"\n                else ps.IntegerParameter\n            )\n            lower_bound, upper_bound, mean, std = _convert_for_normal_parameter(\n                log=param_dict[\"log\"],\n                lower=param_dict.get(\"lower\", None),\n                upper=param_dict.get(\"upper\", None),\n                mu=param_dict[\"mu\"],\n                sigma=param_dict[\"sigma\"],\n            )\n            space._parameters[param_name] = {\n                \"parameter\": parameter_class(\n                    name=param_name,\n                    bounds=(lower_bound, upper_bound),\n                    prior=ps.priors.TruncatedNormal(mean=mean, std=std),\n                    transformation=\"log\" if param_dict[\"log\"] else None,\n                ),\n                \"condition\": condition,\n            }\n\n        elif param_dict[\"type\"] == \"uniform_float\":\n            space._parameters[param_name] = {\n                \"parameter\": ps.ContinuousParameter(\n                    name=param_name,\n                    bounds=(param_dict[\"lower\"], param_dict[\"upper\"]),\n                    transformation=\"log\" if param_dict[\"log\"] else None,\n                ),\n                \"condition\": condition,\n            }\n\n        elif param_dict[\"type\"] == \"ordinal\":\n            space._parameters[param_name] = {\n                \"parameter\": ps.OrdinalParameter(\n                    name=param_name,\n                    values=param_dict[\"sequence\"],\n                ),\n                \"condition\": condition,\n            }\n\n        else:\n            raise NotImplementedError(f\"Unsupported type {param_dict['type']}\")\n\n    return space, names\n</code></pre>"},{"location":"API-Reference/parameterspace/","title":"Parameterspace","text":""},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace","title":"<code> ParameterSpace            (SearchSpace)         </code>","text":"<p>Class representing a parameter space that allows to sampling, converting and checking configurations.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>class ParameterSpace(SearchSpace):\n    \"\"\"Class representing a parameter space that allows to sampling, converting and\n    checking configurations.\n    \"\"\"\n\n    def __init__(self, seed: int = None):\n        super().__init__(seed=seed)\n\n        self._parameters: dict = {}\n        self._constants: dict = {}\n\n    def __len__(self):\n        return len(self._parameters)\n\n    def __iter__(self):\n        return iter(self._parameters.values())\n\n    def __getitem__(self, name):\n        return self._parameters[name]\n\n    def __repr__(self):\n        string = \"ParameterSpace with the following parameters and conditions\\n\"\n        for p in self._parameters.values():\n            string += str(p[\"parameter\"])\n            string += str(p[\"condition\"]) + \"\\n\"\n        return string\n\n    def __eq__(self, other):\n        self_dict = self.to_dict()\n        self_dict.pop(\"bit_generator_state\")\n\n        other_dict = other.to_dict()\n        other_dict.pop(\"bit_generator_state\")\n\n        return self_dict == other_dict\n\n    def seed(self, seed: Union[int, dict] = None) -&gt; None:\n        \"\"\"Reinitialize the random number generator.\n\n        Args:\n            seed: Either an integer seed or a numpy bit generator state dictionary.\n                Defaults to None.\n        \"\"\"\n        if isinstance(seed, dict):\n            self._rng = np.random.default_rng()\n            self._rng.bit_generator.state = seed\n        else:\n            self._rng = np.random.default_rng(seed)\n\n    def copy(self) -&gt; ParameterSpace:\n        return ParameterSpace.from_dict(self.to_dict())\n\n    def add(\n        self,\n        parameter: Union[BaseParameter, ParameterSpace],\n        condition: Callable = None,\n    ):\n        \"\"\"Add a parameter that is only active if condition returns true when called.\n\n        Args:\n            parameter: A parameter or a subspace to be added to this space.\\n\n                Every parameter needs to have a unique name! A `ValueError` is raised if\n                a parameter with the same name already exists in the `ParameterSpace`.\n            condition: Lambda function that returns whether this parameter is active\n                based on values of other parameters in the `ParameterSpace`.\\n\n                The signature is read using introspection to extract on which parameters\n                the condition operates on.\n        \"\"\"\n        if not isinstance(condition, Condition):\n            tmp_condition = Condition(condition)\n            condition = Condition()\n            for n in tmp_condition.all_varnames:\n                condition.merge(self._parameters[n][\"condition\"])\n\n            condition.merge(tmp_condition)\n\n        if isinstance(parameter, ParameterSpace):\n            for pn in parameter.get_parameter_names():\n                p = parameter[pn]\n                tmp_condition = copy.deepcopy(condition).merge(p[\"condition\"])\n                self.add(p[\"parameter\"], tmp_condition)\n        else:\n            if parameter.name in self._parameters:\n                raise ValueError(f\"Parameter {parameter.name} already exists!\")\n            self._parameters[parameter.name] = {\n                \"parameter\": parameter,\n                \"condition\": condition,\n            }\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Transform current `ParameterSpace` into a dictionary representation.\n\n        Returns:\n            Contains \"constants\" and \"parameters\" (with \"condition\").\n        \"\"\"\n\n        parameters = {}\n        for p in self._parameters.values():\n            parameters[p[\"parameter\"].name] = {\n                \"parameter\": p[\"parameter\"].to_dict(),\n                \"condition\": p[\"condition\"].to_dict(),\n            }\n        return {\n            \"bit_generator_state\": self._rng.bit_generator.state,\n            \"parameters\": parameters,\n            \"constants\": copy.deepcopy(self._constants),\n        }\n\n    @staticmethod\n    def from_dict(dict_representation: dict) -&gt; ParameterSpace:\n        \"\"\"\n        Create a new `ParameterSpace` instance with the state passed as\n        dictionary.\n\n        Args:\n            dict_representation: A dictionary representation of a\n                `ParameterSpace`.\n\n        Returns:\n            New class instance\n        \"\"\"\n        return_ps = ParameterSpace()\n        return_ps.seed(dict_representation.get(\"bit_generator_state\"))\n\n        for parameter_dict in dict_representation[\"parameters\"].values():\n            parameter = BaseParameter.from_dict(parameter_dict[\"parameter\"])\n            condition = Condition.from_dict(parameter_dict[\"condition\"])\n            return_ps._parameters[parameter.name] = {\n                \"parameter\": parameter,\n                \"condition\": condition,\n            }\n        return_ps._constants = copy.deepcopy(dict_representation[\"constants\"])\n\n        return return_ps\n\n    def fix(self, **kwargs: Any):\n        \"\"\"Remove all parameters from the parameters list and add treat them as\n        constants.\n\n        The main use-case for this method is to narrow down a generic\n        `ParameterSpace` by fixing certain variables. This could be because of\n        special constraints, or to focus any optimization on a few parameters.\n\n        Note:\n            This method will change the ParameterSpace object irreversibly.\n\n        Args:\n            **kwargs: All arguments to this method have to be keyword arguments\n                with valid parameter names and valid values.\\n\n                The method will change the current `ParameterSpace` such that\n                the numerical representation does not contain any fixed\n                parameters (or always inactive ones).\\n\n                The dictionary representation will still contain the fixed\n                parameters with their respective value.\n\n        Raises:\n            ValueError: In case of not existing parameters or invalid values.\n\n        \"\"\"\n\n        for name, value in kwargs.items():\n            if name not in self._parameters:\n                raise ValueError(\n                    f\"Parameter '{name}' is not part of this ParameterSpace!\"\n                )\n\n            if not self._parameters[name][\"parameter\"].check_value(value):\n                raise ValueError(f\"Invalid value `{value}` for parameter '{name}'!\")\n\n        # remove any constants here that might not be active based on some parameter\n        # values, but are still specified here.\n        actual_constants = copy.copy(kwargs)\n        for n in kwargs:\n            p = self._parameters[n]\n            if p[\"condition\"].all_varnames &lt;= set(kwargs) and not p[\"condition\"](\n                kwargs\n            ):\n                actual_constants.pop(n, None)\n        self._constants.update(**actual_constants)\n\n        for p in list(self._parameters.keys()):\n            if p in self._constants:\n                del self._parameters[p]\n                continue\n\n            try:\n                if self[p][\"condition\"](self._constants):\n                    self[p][\"condition\"] = Condition(None)\n                else:\n                    del self._parameters[p]\n            except ValueError:\n                pass\n\n    def remove(self, name: str):\n        \"\"\"Remove a parameter by name from this `ParameterSpace` instance.\n\n        Note:\n            When removing a parameter from a `ParameterSpace` that has been\n            added to another `ParameterSpace`, the including `ParameterSpace`\n            is not affected.\n\n        Args:\n            name: Name of the parameter.\n\n        Raises:\n            RuntimeError: In case other parameters condition on the parameter\n                that should be removed.\n            KeyError: In case parameter doesn't exist.\n        \"\"\"\n        conditioning_parameters = []\n        for p_name, p in self._parameters.items():\n            if name in p[\"condition\"].all_varnames:\n                conditioning_parameters.append(p_name)\n        if conditioning_parameters:\n            raise RuntimeError(\n                f\"Unable to remove parameter '{name}' \"\n                + f\"because the parameters {conditioning_parameters} condition on it. \"\n                + f\"Please remove the other parameters before removing '{name}'.\"\n            )\n\n        try:\n            self._parameters.pop(name)\n        except KeyError as e:\n            raise KeyError(\n                f\"Parameter '{name}' is not part of the ParameterSpace.\"\n            ) from e\n\n    def get_parameter_names(self) -&gt; List[str]:\n        \"\"\"Get names of all parameters already in the current `ParameterSpace`.\n\n        Returns:\n            Parameter names.\n        \"\"\"\n        return list(self._parameters.keys())\n\n    def get_constant_names(self) -&gt; List[str]:\n        \"\"\"Get names of the parameters set to a constant value via the `fix()` method.\n\n        Returns:\n            Names of constants in the current `ParameterSpace`.\n        \"\"\"\n        return list(self._constants.keys())\n\n    def get_parameter_by_name(self, name: str) -&gt; BaseParameter:\n        \"\"\"Get parameter with the given name.\n\n        Args:\n            name: Name of the parameter.\n\n        Returns:\n            Parameter with the given name.\n\n        Raises:\n            KeyError: In case parameter doesn't exist.\n        \"\"\"\n        try:\n            return self._parameters[name]\n        except KeyError as e:\n            raise KeyError(\n                f\"Parameter '{name}' is not part of the ParameterSpace.\"\n            ) from e\n\n    def sample(\n        self, partial_configuration: dict = None, rng: np.random.Generator = None\n    ) -&gt; dict:\n        \"\"\"Sample a random configuration based on the priors.\n\n        Args:\n            partial_configuration: Partial assignment of certain variables. If not\n                `None`, only the remaining variables are set randomly. All conditions\n                are honored.\n                Right now, there is no check if the partial configuration violates any\n                conditions.\n            rng: A Numpy random number generator used to generate the sample. Overrides\n                the internal random number generator that is set on initialization of\n                the space.\n\n        Raises:\n            ValueError: If a passed value is not valid for the corresponding parameter.\n\n        Returns:\n            Random parameter configuration.\n        \"\"\"\n        if rng is None:\n            rng = self._rng\n\n        config = {} if partial_configuration is None else partial_configuration\n        for n, v in config.items():\n            if not self._parameters[n][\"parameter\"].check_value(v):\n                raise ValueError(f\"{n} = {v} is not valid for this space\")\n\n        config.update(self._constants)\n\n        for n, p in self._parameters.items():\n            if n in config:\n                continue\n            if p[\"condition\"].empty() or p[\"condition\"](config):\n                config[n] = p[\"parameter\"].sample_values(random_state=rng)\n\n        return config\n\n    def log_likelihood(self, configuration: dict) -&gt; float:\n        \"\"\"Compute log-likelihood of a configuration under the given prior.\n\n        Args:\n            configuration: A parameter configuration\n\n        Returns:\n            Log-likelihood value or `NaN` if configuration is invalid.\n        \"\"\"\n        if not self.check_validity(configuration):\n            return np.nan\n        self.remove_inactive(configuration)\n        return self.log_likelihood_numerical(self.to_numerical(configuration))\n\n    def log_likelihood_numerical(self, vector_configuration: np.ndarray) -&gt; float:\n        \"\"\"Compute log-likelihood for the numerical representation of a\n        configuration under the given prior.\n\n        Note:\n            This method assumes that the vector representation is valid! There\n            are no sanity checks at this point. Inactive parameters must have\n            `NaN` values.\n\n        Args:\n            vector_configuration: Numerical vector representation of a\n                configuration.\n\n        Returns:\n            Log-likelihood value\n        \"\"\"\n        ll = 0.0\n        for i, p in enumerate(self._parameters.values()):\n            if np.isfinite(vector_configuration[i]):\n                ll += p[\"parameter\"].loglikelihood_numerical_value(\n                    vector_configuration[i]\n                )\n        return ll\n\n    def check_validity(self, configuration: dict) -&gt; bool:\n        \"\"\"Test whether the provided configuration is complete and valid.\n\n        It checks whether all parameters have a valid value or are not active.\n        A warning is shown describing the issue.\n\n        Args:\n          configuration: The configuration to check.\n\n        Returns:\n            `True` if configuration is valid, `False` if not.\n        \"\"\"\n        for n, p in self._parameters.items():\n            v = configuration.get(n, None)\n            if v is None:\n                if p[\"condition\"](configuration):\n                    warnings.warn(\n                        f\"Parameter {n} should be active, \"\n                        + \"but does not have a value assigned.\\n\"\n                        + f\"Full configuration: {configuration}\",\n                        RuntimeWarning,\n                    )\n                    return False\n            else:\n                if not p[\"condition\"](configuration):\n                    warnings.warn(\n                        f\"Parameter {n} = {v} should not be active!\\n\"\n                        + f\"Full configuration: {configuration}\",\n                        RuntimeWarning,\n                    )\n                    return False\n                if not p[\"parameter\"].check_value(v):\n                    warnings.warn(\n                        f\"Parameter {n} = {v} is not a valid assignment!\\n\"\n                        + f\"Full configuration: {configuration}\",\n                        RuntimeWarning,\n                    )\n                    return False\n        return True\n\n    def remove_inactive(self, configuration: dict) -&gt; dict:\n        \"\"\"Identify and remove parameters that should not have a value because their\n        condition is unsatisfied.\n\n        Args:\n            configuration: Configuration to check.\n\n        Returns:\n            Cleaned configuration.\n        \"\"\"\n        for n, p in self._parameters.items():\n            if not p[\"condition\"](configuration):\n                configuration.pop(n, None)\n        return configuration\n\n    def to_numerical(self, configuration: dict) -&gt; np.ndarray:\n        self.remove_inactive(configuration)\n\n        for name, value in self._constants.items():\n            if name not in configuration:\n                raise ValueError(\n                    f\"Configuration does not contain constant `{name} == {value}`!\"\n                )\n            if configuration[name] != value:\n                raise ValueError(\n                    f\"Constant parameter {name} has value {configuration[name]}, \"\n                    + f\"but should be {value}!\"\n                )\n\n        vec = np.zeros(len(self._parameters), dtype=float)\n        for i, (n, p) in enumerate(self._parameters.items()):\n            v = configuration.get(n, None)\n            vec[i] = p[\"parameter\"].val2num(v)\n        return vec\n\n    def from_numerical(self, vector: np.ndarray) -&gt; dict:\n        conf = {}\n        for i, (n, p) in enumerate(self._parameters.items()):\n            if not np.isnan(vector[i]):\n                conf[n] = p[\"parameter\"].num2val(vector[i])\n        conf.update(self._constants)\n        return self.remove_inactive(conf)\n\n    def has_conditions(self) -&gt; bool:\n        \"\"\"Check if any of the parameters in the current `ParameterSpace` is\n        conditioned on others.\n\n        Returns:\n            `True` of conditions exists, `False` if not.\n        \"\"\"\n        for p in self:\n            if not p[\"condition\"].empty():\n                return True\n        return False\n\n    def get_continuous_bounds(self) -&gt; List[Tuple]:\n        \"\"\"Return the ParameterSpace specific bounds if it is purely continuous.\n\n        Raises:\n            ValueError: If `ParameterSpace` contains non-continuous parameters.\n\n        Returns:\n            Continuous bounds for this benchmark to easily run GP\n        \"\"\"\n        bounds = []\n        for n in self.get_parameter_names():\n            p = self[n][\"parameter\"]\n            if not p.is_continuous:\n                raise ValueError(\n                    f\"Parameterspace contains a non-continuous parameter:\\n{p}\"\n                )\n            bounds.append(tuple(p.get_numerical_bounds()))\n        return bounds\n\n    def to_latex_table(self, name_dict: Optional[dict] = None) -&gt; str:\n        \"\"\"Construct LaTeX string for a table that shows the `ParameterSpace`\n        with names, bounds and transformations.\n\n        Args:\n            name_dict: Mapping of parameter name in `ParameterSpace` to name\n                to be rendered in LaTeX table.\n\n        Returns:\n            LaTeX table representation\n        \"\"\"\n        try:\n            # pylint: disable=import-outside-toplevel\n            from num2tex import configure as num2tex_configure\n            from num2tex import num2tex\n\n            # pylint: enable=import-outside-toplevel\n        except ImportError as e:\n            raise RuntimeError(\n                \"To use this functionality, please install num2tex.\"\n            ) from e\n\n        num2tex_configure(exp_format=\"cdot\")\n\n        name_dict = {} if name_dict is None else name_dict\n\n        latex_strs = [\n            \"\\\\begin{tabular}{c c c c c}\",\n            \"\\\\hline\",\n            \"Parameter Name &amp; Type &amp; Values &amp; Transformation &amp; Prior \\\\\\\\\",\n            \"\\\\hline\",\n        ]\n\n        for parameter_name, parameter_value in self._parameters.items():\n            parameter = parameter_value[\"parameter\"]\n\n            name_str = name_dict.get(parameter_name, parameter.name)\n            transformation_name = type(parameter._transformation).__name__\n            prior_name = type(parameter._prior).__name__\n\n            if isinstance(parameter, IntegerParameter):\n                type_str = \"Integer\"\n                values_str = f\"$[{parameter.bounds[0]}, {parameter.bounds[1]}]$\"\n                transformation_str = \"Log\" if \"Log\" in transformation_name else \"\"\n                prior_str = prior_name\n\n            elif isinstance(parameter, ContinuousParameter):\n                type_str = \"Float\"\n                prior_str = prior_name\n\n                if \"Log\" in transformation_name:\n                    transformation_str = \"Log\"\n                    lower_bound = num2tex(parameter.bounds[0], precision=2)\n                    upper_bound = num2tex(parameter.bounds[1], precision=2)\n                    values_str = f\"$[{lower_bound}, {upper_bound}]$\"\n                else:\n                    transformation_str = \" \"\n                    values_str = f\"$[{parameter.bounds[0]}, {parameter.bounds[1]}]$\"\n\n            elif isinstance(parameter, CategoricalParameter):\n                type_str = \"Categorical\"\n                values_str = \"[\" + \", \".join(parameter.values) + \"]\"\n                transformation_str = \" \"\n                prior_probs = parameter._prior.probabilities\n                prior_str = (\n                    \"[\" + \",\".join(map(lambda p: f\"{p:3.2f}\", prior_probs)) + \"]\"\n                )\n\n            elif isinstance(parameter, OrdinalParameter):\n                type_str = \"Ordinal\"\n                values_str = \"[\" + \", \".join(parameter.values) + \"]\"\n                transformation_str = \" \"\n                prior_str = prior_name\n\n            else:\n                raise ValueError(f\"Unknown parameter type {type(parameter)}\")\n\n            latex_strs.append(\n                \" &amp; \".join(\n                    [name_str, type_str, values_str, transformation_str, prior_str]\n                )\n                + \"\\\\\\\\\"\n            )\n\n        latex_strs.extend([\"\\\\hline\", \"\\\\end{tabular}\"])\n        return \"\\n\".join(latex_strs)\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.add","title":"<code>add(self, parameter, condition=None)</code>","text":"<p>Add a parameter that is only active if condition returns true when called.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>Union[BaseParameter, ParameterSpace]</code> <p>A parameter or a subspace to be added to this space.</p> <p>Every parameter needs to have a unique name! A <code>ValueError</code> is raised if a parameter with the same name already exists in the <code>ParameterSpace</code>.</p> required <code>condition</code> <code>Callable</code> <p>Lambda function that returns whether this parameter is active based on values of other parameters in the <code>ParameterSpace</code>.</p> <p>The signature is read using introspection to extract on which parameters the condition operates on.</p> <code>None</code> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def add(\n    self,\n    parameter: Union[BaseParameter, ParameterSpace],\n    condition: Callable = None,\n):\n    \"\"\"Add a parameter that is only active if condition returns true when called.\n\n    Args:\n        parameter: A parameter or a subspace to be added to this space.\\n\n            Every parameter needs to have a unique name! A `ValueError` is raised if\n            a parameter with the same name already exists in the `ParameterSpace`.\n        condition: Lambda function that returns whether this parameter is active\n            based on values of other parameters in the `ParameterSpace`.\\n\n            The signature is read using introspection to extract on which parameters\n            the condition operates on.\n    \"\"\"\n    if not isinstance(condition, Condition):\n        tmp_condition = Condition(condition)\n        condition = Condition()\n        for n in tmp_condition.all_varnames:\n            condition.merge(self._parameters[n][\"condition\"])\n\n        condition.merge(tmp_condition)\n\n    if isinstance(parameter, ParameterSpace):\n        for pn in parameter.get_parameter_names():\n            p = parameter[pn]\n            tmp_condition = copy.deepcopy(condition).merge(p[\"condition\"])\n            self.add(p[\"parameter\"], tmp_condition)\n    else:\n        if parameter.name in self._parameters:\n            raise ValueError(f\"Parameter {parameter.name} already exists!\")\n        self._parameters[parameter.name] = {\n            \"parameter\": parameter,\n            \"condition\": condition,\n        }\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.check_validity","title":"<code>check_validity(self, configuration)</code>","text":"<p>Test whether the provided configuration is complete and valid.</p> <p>It checks whether all parameters have a valid value or are not active. A warning is shown describing the issue.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>dict</code> <p>The configuration to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if configuration is valid, <code>False</code> if not.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def check_validity(self, configuration: dict) -&gt; bool:\n    \"\"\"Test whether the provided configuration is complete and valid.\n\n    It checks whether all parameters have a valid value or are not active.\n    A warning is shown describing the issue.\n\n    Args:\n      configuration: The configuration to check.\n\n    Returns:\n        `True` if configuration is valid, `False` if not.\n    \"\"\"\n    for n, p in self._parameters.items():\n        v = configuration.get(n, None)\n        if v is None:\n            if p[\"condition\"](configuration):\n                warnings.warn(\n                    f\"Parameter {n} should be active, \"\n                    + \"but does not have a value assigned.\\n\"\n                    + f\"Full configuration: {configuration}\",\n                    RuntimeWarning,\n                )\n                return False\n        else:\n            if not p[\"condition\"](configuration):\n                warnings.warn(\n                    f\"Parameter {n} = {v} should not be active!\\n\"\n                    + f\"Full configuration: {configuration}\",\n                    RuntimeWarning,\n                )\n                return False\n            if not p[\"parameter\"].check_value(v):\n                warnings.warn(\n                    f\"Parameter {n} = {v} is not a valid assignment!\\n\"\n                    + f\"Full configuration: {configuration}\",\n                    RuntimeWarning,\n                )\n                return False\n    return True\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.copy","title":"<code>copy(self)</code>","text":"<p>Get a copy that behaves exactly like the original <code>SearchSpace</code>. Call <code>seed()</code> on the copy to get independent samples.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def copy(self) -&gt; ParameterSpace:\n    return ParameterSpace.from_dict(self.to_dict())\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.fix","title":"<code>fix(self, **kwargs)</code>","text":"<p>Remove all parameters from the parameters list and add treat them as constants.</p> <p>The main use-case for this method is to narrow down a generic <code>ParameterSpace</code> by fixing certain variables. This could be because of special constraints, or to focus any optimization on a few parameters.</p> <p>Note</p> <p>This method will change the ParameterSpace object irreversibly.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>Any</code> <p>All arguments to this method have to be keyword arguments with valid parameter names and valid values.</p> <p>The method will change the current <code>ParameterSpace</code> such that the numerical representation does not contain any fixed parameters (or always inactive ones).</p> <p>The dictionary representation will still contain the fixed parameters with their respective value.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>In case of not existing parameters or invalid values.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def fix(self, **kwargs: Any):\n    \"\"\"Remove all parameters from the parameters list and add treat them as\n    constants.\n\n    The main use-case for this method is to narrow down a generic\n    `ParameterSpace` by fixing certain variables. This could be because of\n    special constraints, or to focus any optimization on a few parameters.\n\n    Note:\n        This method will change the ParameterSpace object irreversibly.\n\n    Args:\n        **kwargs: All arguments to this method have to be keyword arguments\n            with valid parameter names and valid values.\\n\n            The method will change the current `ParameterSpace` such that\n            the numerical representation does not contain any fixed\n            parameters (or always inactive ones).\\n\n            The dictionary representation will still contain the fixed\n            parameters with their respective value.\n\n    Raises:\n        ValueError: In case of not existing parameters or invalid values.\n\n    \"\"\"\n\n    for name, value in kwargs.items():\n        if name not in self._parameters:\n            raise ValueError(\n                f\"Parameter '{name}' is not part of this ParameterSpace!\"\n            )\n\n        if not self._parameters[name][\"parameter\"].check_value(value):\n            raise ValueError(f\"Invalid value `{value}` for parameter '{name}'!\")\n\n    # remove any constants here that might not be active based on some parameter\n    # values, but are still specified here.\n    actual_constants = copy.copy(kwargs)\n    for n in kwargs:\n        p = self._parameters[n]\n        if p[\"condition\"].all_varnames &lt;= set(kwargs) and not p[\"condition\"](\n            kwargs\n        ):\n            actual_constants.pop(n, None)\n    self._constants.update(**actual_constants)\n\n    for p in list(self._parameters.keys()):\n        if p in self._constants:\n            del self._parameters[p]\n            continue\n\n        try:\n            if self[p][\"condition\"](self._constants):\n                self[p][\"condition\"] = Condition(None)\n            else:\n                del self._parameters[p]\n        except ValueError:\n            pass\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.from_dict","title":"<code>from_dict(dict_representation)</code>  <code>staticmethod</code>","text":"<p>Create a new <code>ParameterSpace</code> instance with the state passed as dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dict_representation</code> <code>dict</code> <p>A dictionary representation of a <code>ParameterSpace</code>.</p> required <p>Returns:</p> Type Description <code>ParameterSpace</code> <p>New class instance</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>@staticmethod\ndef from_dict(dict_representation: dict) -&gt; ParameterSpace:\n    \"\"\"\n    Create a new `ParameterSpace` instance with the state passed as\n    dictionary.\n\n    Args:\n        dict_representation: A dictionary representation of a\n            `ParameterSpace`.\n\n    Returns:\n        New class instance\n    \"\"\"\n    return_ps = ParameterSpace()\n    return_ps.seed(dict_representation.get(\"bit_generator_state\"))\n\n    for parameter_dict in dict_representation[\"parameters\"].values():\n        parameter = BaseParameter.from_dict(parameter_dict[\"parameter\"])\n        condition = Condition.from_dict(parameter_dict[\"condition\"])\n        return_ps._parameters[parameter.name] = {\n            \"parameter\": parameter,\n            \"condition\": condition,\n        }\n    return_ps._constants = copy.deepcopy(dict_representation[\"constants\"])\n\n    return return_ps\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.from_numerical","title":"<code>from_numerical(self, vector)</code>","text":"<p>Convert a np.float64 type vector numerical representation of a configuration from this space to a dictionary representation.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def from_numerical(self, vector: np.ndarray) -&gt; dict:\n    conf = {}\n    for i, (n, p) in enumerate(self._parameters.items()):\n        if not np.isnan(vector[i]):\n            conf[n] = p[\"parameter\"].num2val(vector[i])\n    conf.update(self._constants)\n    return self.remove_inactive(conf)\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.get_constant_names","title":"<code>get_constant_names(self)</code>","text":"<p>Get names of the parameters set to a constant value via the <code>fix()</code> method.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Names of constants in the current <code>ParameterSpace</code>.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def get_constant_names(self) -&gt; List[str]:\n    \"\"\"Get names of the parameters set to a constant value via the `fix()` method.\n\n    Returns:\n        Names of constants in the current `ParameterSpace`.\n    \"\"\"\n    return list(self._constants.keys())\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.get_continuous_bounds","title":"<code>get_continuous_bounds(self)</code>","text":"<p>Return the ParameterSpace specific bounds if it is purely continuous.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If <code>ParameterSpace</code> contains non-continuous parameters.</p> <p>Returns:</p> Type Description <code>List[Tuple]</code> <p>Continuous bounds for this benchmark to easily run GP</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def get_continuous_bounds(self) -&gt; List[Tuple]:\n    \"\"\"Return the ParameterSpace specific bounds if it is purely continuous.\n\n    Raises:\n        ValueError: If `ParameterSpace` contains non-continuous parameters.\n\n    Returns:\n        Continuous bounds for this benchmark to easily run GP\n    \"\"\"\n    bounds = []\n    for n in self.get_parameter_names():\n        p = self[n][\"parameter\"]\n        if not p.is_continuous:\n            raise ValueError(\n                f\"Parameterspace contains a non-continuous parameter:\\n{p}\"\n            )\n        bounds.append(tuple(p.get_numerical_bounds()))\n    return bounds\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.get_parameter_by_name","title":"<code>get_parameter_by_name(self, name)</code>","text":"<p>Get parameter with the given name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <p>Returns:</p> Type Description <code>BaseParameter</code> <p>Parameter with the given name.</p> <p>Exceptions:</p> Type Description <code>KeyError</code> <p>In case parameter doesn't exist.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def get_parameter_by_name(self, name: str) -&gt; BaseParameter:\n    \"\"\"Get parameter with the given name.\n\n    Args:\n        name: Name of the parameter.\n\n    Returns:\n        Parameter with the given name.\n\n    Raises:\n        KeyError: In case parameter doesn't exist.\n    \"\"\"\n    try:\n        return self._parameters[name]\n    except KeyError as e:\n        raise KeyError(\n            f\"Parameter '{name}' is not part of the ParameterSpace.\"\n        ) from e\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.get_parameter_names","title":"<code>get_parameter_names(self)</code>","text":"<p>Get names of all parameters already in the current <code>ParameterSpace</code>.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>Parameter names.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def get_parameter_names(self) -&gt; List[str]:\n    \"\"\"Get names of all parameters already in the current `ParameterSpace`.\n\n    Returns:\n        Parameter names.\n    \"\"\"\n    return list(self._parameters.keys())\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.has_conditions","title":"<code>has_conditions(self)</code>","text":"<p>Check if any of the parameters in the current <code>ParameterSpace</code> is conditioned on others.</p> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> of conditions exists, <code>False</code> if not.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def has_conditions(self) -&gt; bool:\n    \"\"\"Check if any of the parameters in the current `ParameterSpace` is\n    conditioned on others.\n\n    Returns:\n        `True` of conditions exists, `False` if not.\n    \"\"\"\n    for p in self:\n        if not p[\"condition\"].empty():\n            return True\n    return False\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.log_likelihood","title":"<code>log_likelihood(self, configuration)</code>","text":"<p>Compute log-likelihood of a configuration under the given prior.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>dict</code> <p>A parameter configuration</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log-likelihood value or <code>NaN</code> if configuration is invalid.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def log_likelihood(self, configuration: dict) -&gt; float:\n    \"\"\"Compute log-likelihood of a configuration under the given prior.\n\n    Args:\n        configuration: A parameter configuration\n\n    Returns:\n        Log-likelihood value or `NaN` if configuration is invalid.\n    \"\"\"\n    if not self.check_validity(configuration):\n        return np.nan\n    self.remove_inactive(configuration)\n    return self.log_likelihood_numerical(self.to_numerical(configuration))\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.log_likelihood_numerical","title":"<code>log_likelihood_numerical(self, vector_configuration)</code>","text":"<p>Compute log-likelihood for the numerical representation of a configuration under the given prior.</p> <p>Note</p> <p>This method assumes that the vector representation is valid! There are no sanity checks at this point. Inactive parameters must have <code>NaN</code> values.</p> <p>Parameters:</p> Name Type Description Default <code>vector_configuration</code> <code>np.ndarray</code> <p>Numerical vector representation of a configuration.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Log-likelihood value</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def log_likelihood_numerical(self, vector_configuration: np.ndarray) -&gt; float:\n    \"\"\"Compute log-likelihood for the numerical representation of a\n    configuration under the given prior.\n\n    Note:\n        This method assumes that the vector representation is valid! There\n        are no sanity checks at this point. Inactive parameters must have\n        `NaN` values.\n\n    Args:\n        vector_configuration: Numerical vector representation of a\n            configuration.\n\n    Returns:\n        Log-likelihood value\n    \"\"\"\n    ll = 0.0\n    for i, p in enumerate(self._parameters.values()):\n        if np.isfinite(vector_configuration[i]):\n            ll += p[\"parameter\"].loglikelihood_numerical_value(\n                vector_configuration[i]\n            )\n    return ll\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.remove","title":"<code>remove(self, name)</code>","text":"<p>Remove a parameter by name from this <code>ParameterSpace</code> instance.</p> <p>Note</p> <p>When removing a parameter from a <code>ParameterSpace</code> that has been added to another <code>ParameterSpace</code>, the including <code>ParameterSpace</code> is not affected.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <p>Exceptions:</p> Type Description <code>RuntimeError</code> <p>In case other parameters condition on the parameter that should be removed.</p> <code>KeyError</code> <p>In case parameter doesn't exist.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def remove(self, name: str):\n    \"\"\"Remove a parameter by name from this `ParameterSpace` instance.\n\n    Note:\n        When removing a parameter from a `ParameterSpace` that has been\n        added to another `ParameterSpace`, the including `ParameterSpace`\n        is not affected.\n\n    Args:\n        name: Name of the parameter.\n\n    Raises:\n        RuntimeError: In case other parameters condition on the parameter\n            that should be removed.\n        KeyError: In case parameter doesn't exist.\n    \"\"\"\n    conditioning_parameters = []\n    for p_name, p in self._parameters.items():\n        if name in p[\"condition\"].all_varnames:\n            conditioning_parameters.append(p_name)\n    if conditioning_parameters:\n        raise RuntimeError(\n            f\"Unable to remove parameter '{name}' \"\n            + f\"because the parameters {conditioning_parameters} condition on it. \"\n            + f\"Please remove the other parameters before removing '{name}'.\"\n        )\n\n    try:\n        self._parameters.pop(name)\n    except KeyError as e:\n        raise KeyError(\n            f\"Parameter '{name}' is not part of the ParameterSpace.\"\n        ) from e\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.remove_inactive","title":"<code>remove_inactive(self, configuration)</code>","text":"<p>Identify and remove parameters that should not have a value because their condition is unsatisfied.</p> <p>Parameters:</p> Name Type Description Default <code>configuration</code> <code>dict</code> <p>Configuration to check.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Cleaned configuration.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def remove_inactive(self, configuration: dict) -&gt; dict:\n    \"\"\"Identify and remove parameters that should not have a value because their\n    condition is unsatisfied.\n\n    Args:\n        configuration: Configuration to check.\n\n    Returns:\n        Cleaned configuration.\n    \"\"\"\n    for n, p in self._parameters.items():\n        if not p[\"condition\"](configuration):\n            configuration.pop(n, None)\n    return configuration\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.sample","title":"<code>sample(self, partial_configuration=None, rng=None)</code>","text":"<p>Sample a random configuration based on the priors.</p> <p>Parameters:</p> Name Type Description Default <code>partial_configuration</code> <code>dict</code> <p>Partial assignment of certain variables. If not <code>None</code>, only the remaining variables are set randomly. All conditions are honored. Right now, there is no check if the partial configuration violates any conditions.</p> <code>None</code> <code>rng</code> <code>np.random.Generator</code> <p>A Numpy random number generator used to generate the sample. Overrides the internal random number generator that is set on initialization of the space.</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If a passed value is not valid for the corresponding parameter.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Random parameter configuration.</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def sample(\n    self, partial_configuration: dict = None, rng: np.random.Generator = None\n) -&gt; dict:\n    \"\"\"Sample a random configuration based on the priors.\n\n    Args:\n        partial_configuration: Partial assignment of certain variables. If not\n            `None`, only the remaining variables are set randomly. All conditions\n            are honored.\n            Right now, there is no check if the partial configuration violates any\n            conditions.\n        rng: A Numpy random number generator used to generate the sample. Overrides\n            the internal random number generator that is set on initialization of\n            the space.\n\n    Raises:\n        ValueError: If a passed value is not valid for the corresponding parameter.\n\n    Returns:\n        Random parameter configuration.\n    \"\"\"\n    if rng is None:\n        rng = self._rng\n\n    config = {} if partial_configuration is None else partial_configuration\n    for n, v in config.items():\n        if not self._parameters[n][\"parameter\"].check_value(v):\n            raise ValueError(f\"{n} = {v} is not valid for this space\")\n\n    config.update(self._constants)\n\n    for n, p in self._parameters.items():\n        if n in config:\n            continue\n        if p[\"condition\"].empty() or p[\"condition\"](config):\n            config[n] = p[\"parameter\"].sample_values(random_state=rng)\n\n    return config\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.seed","title":"<code>seed(self, seed=None)</code>","text":"<p>Reinitialize the random number generator.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>Union[int, dict]</code> <p>Either an integer seed or a numpy bit generator state dictionary. Defaults to None.</p> <code>None</code> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def seed(self, seed: Union[int, dict] = None) -&gt; None:\n    \"\"\"Reinitialize the random number generator.\n\n    Args:\n        seed: Either an integer seed or a numpy bit generator state dictionary.\n            Defaults to None.\n    \"\"\"\n    if isinstance(seed, dict):\n        self._rng = np.random.default_rng()\n        self._rng.bit_generator.state = seed\n    else:\n        self._rng = np.random.default_rng(seed)\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.to_dict","title":"<code>to_dict(self)</code>","text":"<p>Transform current <code>ParameterSpace</code> into a dictionary representation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Contains \"constants\" and \"parameters\" (with \"condition\").</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Transform current `ParameterSpace` into a dictionary representation.\n\n    Returns:\n        Contains \"constants\" and \"parameters\" (with \"condition\").\n    \"\"\"\n\n    parameters = {}\n    for p in self._parameters.values():\n        parameters[p[\"parameter\"].name] = {\n            \"parameter\": p[\"parameter\"].to_dict(),\n            \"condition\": p[\"condition\"].to_dict(),\n        }\n    return {\n        \"bit_generator_state\": self._rng.bit_generator.state,\n        \"parameters\": parameters,\n        \"constants\": copy.deepcopy(self._constants),\n    }\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.to_latex_table","title":"<code>to_latex_table(self, name_dict=None)</code>","text":"<p>Construct LaTeX string for a table that shows the <code>ParameterSpace</code> with names, bounds and transformations.</p> <p>Parameters:</p> Name Type Description Default <code>name_dict</code> <code>Optional[dict]</code> <p>Mapping of parameter name in <code>ParameterSpace</code> to name to be rendered in LaTeX table.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>LaTeX table representation</p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def to_latex_table(self, name_dict: Optional[dict] = None) -&gt; str:\n    \"\"\"Construct LaTeX string for a table that shows the `ParameterSpace`\n    with names, bounds and transformations.\n\n    Args:\n        name_dict: Mapping of parameter name in `ParameterSpace` to name\n            to be rendered in LaTeX table.\n\n    Returns:\n        LaTeX table representation\n    \"\"\"\n    try:\n        # pylint: disable=import-outside-toplevel\n        from num2tex import configure as num2tex_configure\n        from num2tex import num2tex\n\n        # pylint: enable=import-outside-toplevel\n    except ImportError as e:\n        raise RuntimeError(\n            \"To use this functionality, please install num2tex.\"\n        ) from e\n\n    num2tex_configure(exp_format=\"cdot\")\n\n    name_dict = {} if name_dict is None else name_dict\n\n    latex_strs = [\n        \"\\\\begin{tabular}{c c c c c}\",\n        \"\\\\hline\",\n        \"Parameter Name &amp; Type &amp; Values &amp; Transformation &amp; Prior \\\\\\\\\",\n        \"\\\\hline\",\n    ]\n\n    for parameter_name, parameter_value in self._parameters.items():\n        parameter = parameter_value[\"parameter\"]\n\n        name_str = name_dict.get(parameter_name, parameter.name)\n        transformation_name = type(parameter._transformation).__name__\n        prior_name = type(parameter._prior).__name__\n\n        if isinstance(parameter, IntegerParameter):\n            type_str = \"Integer\"\n            values_str = f\"$[{parameter.bounds[0]}, {parameter.bounds[1]}]$\"\n            transformation_str = \"Log\" if \"Log\" in transformation_name else \"\"\n            prior_str = prior_name\n\n        elif isinstance(parameter, ContinuousParameter):\n            type_str = \"Float\"\n            prior_str = prior_name\n\n            if \"Log\" in transformation_name:\n                transformation_str = \"Log\"\n                lower_bound = num2tex(parameter.bounds[0], precision=2)\n                upper_bound = num2tex(parameter.bounds[1], precision=2)\n                values_str = f\"$[{lower_bound}, {upper_bound}]$\"\n            else:\n                transformation_str = \" \"\n                values_str = f\"$[{parameter.bounds[0]}, {parameter.bounds[1]}]$\"\n\n        elif isinstance(parameter, CategoricalParameter):\n            type_str = \"Categorical\"\n            values_str = \"[\" + \", \".join(parameter.values) + \"]\"\n            transformation_str = \" \"\n            prior_probs = parameter._prior.probabilities\n            prior_str = (\n                \"[\" + \",\".join(map(lambda p: f\"{p:3.2f}\", prior_probs)) + \"]\"\n            )\n\n        elif isinstance(parameter, OrdinalParameter):\n            type_str = \"Ordinal\"\n            values_str = \"[\" + \", \".join(parameter.values) + \"]\"\n            transformation_str = \" \"\n            prior_str = prior_name\n\n        else:\n            raise ValueError(f\"Unknown parameter type {type(parameter)}\")\n\n        latex_strs.append(\n            \" &amp; \".join(\n                [name_str, type_str, values_str, transformation_str, prior_str]\n            )\n            + \"\\\\\\\\\"\n        )\n\n    latex_strs.extend([\"\\\\hline\", \"\\\\end{tabular}\"])\n    return \"\\n\".join(latex_strs)\n</code></pre>"},{"location":"API-Reference/parameterspace/#parameterspace.parameterspace.ParameterSpace.to_numerical","title":"<code>to_numerical(self, configuration)</code>","text":"<p>Given a configuration from this space, create a numerical vector representation. The transformed representation needs to be between 0 and 1 (uniform), including integers, ordinal and categoricals. Inactive parameters have to be represented with <code>np.nan</code></p> Source code in <code>parameterspace/parameterspace.py</code> <pre><code>def to_numerical(self, configuration: dict) -&gt; np.ndarray:\n    self.remove_inactive(configuration)\n\n    for name, value in self._constants.items():\n        if name not in configuration:\n            raise ValueError(\n                f\"Configuration does not contain constant `{name} == {value}`!\"\n            )\n        if configuration[name] != value:\n            raise ValueError(\n                f\"Constant parameter {name} has value {configuration[name]}, \"\n                + f\"but should be {value}!\"\n            )\n\n    vec = np.zeros(len(self._parameters), dtype=float)\n    for i, (n, p) in enumerate(self._parameters.items()):\n        v = configuration.get(n, None)\n        vec[i] = p[\"parameter\"].val2num(v)\n    return vec\n</code></pre>"},{"location":"API-Reference/utils/","title":"Utils","text":""},{"location":"API-Reference/utils/#parameterspace.utils.extract_lambda_information","title":"<code>extract_lambda_information(source_lines)</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>source_lines</code> <code>Iterable</code> <p>[description]</p> required <p>Exceptions:</p> Type Description <code>RuntimeError</code> <p>If function definition is not a valid Lambda function.</p> <p>Returns:</p> Type Description <code>Tuple[list, str]</code> <p>[description]</p> Source code in <code>parameterspace/utils.py</code> <pre><code>def extract_lambda_information(source_lines: Iterable) -&gt; Tuple[list, str]:\n    \"\"\"[summary]\n\n    Args:\n        source_lines: [description]\n\n    Raises:\n        RuntimeError: If function definition is not a valid Lambda function.\n\n    Returns:\n        [description]\n    \"\"\"\n    condensed_code = \"\".join(source_lines).replace(os.linesep, \"\")  # join lines\n    condensed_code = \" \".join(\n        condensed_code.split()\n    )  # replace multiple spaces by a single one\n\n    try:\n        signature, body = condensed_code.split(\"lambda\")[1].split(\":\")\n    except IndexError as e:\n        raise RuntimeError(\n            \"The function definition does not look like a valid Lambda function:\\n\"\n            + \"\".join(source_lines)\n        ) from e\n\n    while len(body) &gt; 1:\n        lambda_def = f\"lambda {signature}: {body}\"\n        try:\n            _ = compile(lambda_def, \"&lt;unused filename&gt;\", \"eval\")\n            break\n        except SyntaxError:\n            body = body[:-1]\n\n    variables = [s.strip() for s in signature.split(\",\")]\n\n    return variables, body.strip().rstrip(\",\")\n</code></pre>"},{"location":"API-Reference/utils/#parameterspace.utils.store_init_arguments","title":"<code>store_init_arguments(init_method)</code>","text":"<p>Stores init arguments (including keyword arguments) and auto converts <code>numpy.ndarray</code>s to <code>list</code>s for json serializability.</p> <p>Parameters:</p> Name Type Description Default <code>init_method</code> <code>Callable</code> <p>[description]</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>[description]</p> Source code in <code>parameterspace/utils.py</code> <pre><code>def store_init_arguments(init_method: Callable) -&gt; Callable:\n    \"\"\"Stores init arguments (including keyword arguments) and auto converts\n    `numpy.ndarray`s to `list`s for json serializability.\n\n    Args:\n        init_method: [description]\n\n    Returns:\n        [description]\n    \"\"\"\n\n    @wraps(init_method)\n    def wrapper(self, *args, **kwargs):\n        args = [a.tolist() if isinstance(a, np.ndarray) else a for a in args]\n\n        for k, k_value in kwargs.items():\n            if isinstance(k_value, np.ndarray):\n                kwargs[k] = k_value.tolist()\n\n        self._init_args = args\n        self._init_kwargs = kwargs\n        init_method(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"API-Reference/utils/#parameterspace.utils.verify_lambda","title":"<code>verify_lambda(variables, body)</code>","text":"<p>Check serialized lambda expression for malicious code.</p> <p>Parameters:</p> Name Type Description Default <code>variables</code> <code>List[str]</code> <p>List of the variable names used in the function body.</p> required <code>body</code> <code>str</code> <p>Function body string representation to check for allowed expressions.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the function body is considered safe.</p> Source code in <code>parameterspace/utils.py</code> <pre><code>def verify_lambda(variables: List[str], body: str) -&gt; bool:\n    \"\"\"Check serialized lambda expression for malicious code.\n\n    Args:\n        variables: List of the variable names used in the function body.\n        body: Function body string representation to check for allowed expressions.\n\n    Returns:\n        True if the function body is considered safe.\n    \"\"\"\n\n    if len(body) &gt; 200:\n        return False\n\n    if \"eval(\" in body:\n        return False\n\n    forbidden_characters = \"\\\\;\"\n\n    for c in forbidden_characters:\n        if c in body:\n            return False\n\n    allowed_characters = \".,0123456789+-*/()&lt;=!&gt; \"\n    allowed_functions = [\n        \"math.sin\",\n        \"math.cos\",\n        \"math.exp\",\n        \"math.log\",\n        \"or\",\n        \"and\",\n        \"not\",\n        \"in\",\n    ]\n\n    for vn in variables:\n        body = body.replace(vn, \"\")\n\n    for fn in allowed_functions:\n        body = body.replace(fn, \"\")\n\n    for c in allowed_characters:\n        body = body.replace(c, \"\")\n\n    # remove all single quoted strings\n    matches = re.findall(r\"\\'(.+?)\\'\", body)\n    for m in matches:\n        body = body.replace(\"'\" + m + \"'\", \"\")\n\n    # remove all double quoted strings\n    matches = re.findall(r\"\\\"(.+?)\\\"\", body)\n    for m in matches:\n        body = body.replace('\"' + m + '\"', \"\")\n\n    if len(body) &gt; 0:\n        print(\"body:\", body)\n        return False\n\n    return True\n</code></pre>"},{"location":"API-Reference/parameters/base/","title":"Base","text":""},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter","title":"<code> BaseParameter            (ABC)         </code>","text":"<p>Base parameter class defining the API.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>class BaseParameter(abc.ABC):\n    \"\"\"Base parameter class defining the API.\"\"\"\n\n    # pylint: disable-next=too-many-positional-arguments\n    def __init__(\n        self,\n        name: str,\n        prior: BasePrior,\n        transformation: BaseTransformation,\n        is_continuous: bool,\n        is_ordered: bool,\n        num_values: Union[int, float],\n        inactive_numerical_value: Optional[float] = np.nan,\n    ):\n        \"\"\"\n        Initialize with options common to all parameters.\n\n        Args:\n            name: Name of the parameter.\n            prior: Defines the pdf from which random samples are drawn. Default (`None`)\n                corresponds to a uniform prior. Note that the prior's bounds must match\n                the transformation's output bounds.\n            transformation: Defines the transformation from the values to their\n                numerical representation. Note that the transformation's output bounds\n                must match the prior's bounds.\n            is_continuous: Indicates whether this parameter varies continuously, i.e.\n                is a `float`.\n            is_ordered: Indicates whether this parameter has a natural ordering of it's\n                values.\n            num_values: Number of possible values. For ordinal, categorical, and integer\n                parameters, this equals the number of unique values. For continuous\n                parameters, it equals np.inf (even though technically there is only a\n                finite number of float values).\n            inactive_numerical_value: Placeholder value for this parameter in case it\n                is not active\n        \"\"\"\n        if not is_valid_python_variable_name(name):\n            raise ValueError(f\"{name} needs to be a valid Python variable name.\")\n\n        self.name = name\n        self._prior = prior\n        self._transformation = transformation\n        self._inactive_numerical_value = inactive_numerical_value\n        self.transformed_bounds = self._transformation.output_bounds\n\n        self._init_args: Tuple\n        self._init_kwargs: Dict\n\n        assert np.allclose(self._prior.bounds, self.transformed_bounds, 1e-6), (\n            f\"Missmatch between the prior bounds ({self._prior.bounds})\"\n            + f\"and the transformation's bounds ({self.transformed_bounds})!\"\n        )\n\n        self.is_continuous = is_continuous\n        self.is_ordered = is_ordered\n        self.num_values = num_values\n\n    def __repr__(self):\n        \"\"\"Basic info about a parameter common to all types.\"\"\"\n        string = f\"Name: {self.name}\\n\"\n        string += f\"Type: {self.__class__}\\n\"\n        string += f\"Prior: {self._prior.__repr__()}\\n\"\n        string += f\"is continuous: {self.is_continuous}\\n\"\n        string += f\"is ordered: {self.is_ordered}\\n\"\n        string += f\"num_values: {self.num_values}\\n\"\n        return string\n\n    def sample_values(self, num_samples=None, random_state=np.random):\n        \"\"\"Generate randomly sampled values based on the prior.\"\"\"\n        numerical_samples = self.sample_numerical_values(num_samples, random_state)\n        if num_samples is None:\n            return self._transformation.inverse(numerical_samples)\n        return [\n            self._transformation.inverse(num_value) for num_value in numerical_samples\n        ]\n\n    def sample_numerical_values(self, num_samples=None, random_state=np.random):\n        \"\"\"Generate random values based on the prior, but in the transformed space.\"\"\"\n        return self._prior.sample(num_samples, random_state=random_state)\n\n    def val2num(self, value):\n        \"\"\"Translate a value into its numerical representation (incl. normalization).\"\"\"\n        if value is None:\n            return self._inactive_numerical_value\n        return self._transformation(value)\n\n    def num2val(self, numerical_value):\n        \"\"\"Translate the numerical representation into the actual value.\"\"\"\n        return self._transformation.inverse(numerical_value)\n\n    def check_numerical_value(self, numerical_value):\n        \"\"\"Check if the numerical representation of the value is valid.\"\"\"\n        return (\n            self.transformed_bounds[0] &lt;= numerical_value &lt;= self.transformed_bounds[1]\n        )\n\n    def pdf_numerical_value(self, numerical_value):\n        \"\"\"Compute the PDF based on the prior.\"\"\"\n        return self._prior.pdf(numerical_value) * self._transformation.jacobian_factor(\n            numerical_value\n        )\n\n    def loglikelihood_numerical_value(self, numerical_value):\n        \"\"\"Compute the loglikelihood based on the prior.\"\"\"\n        return self._prior.loglikelihood(numerical_value) + np.log(\n            self._transformation.jacobian_factor(numerical_value)\n        )\n\n    def loglikelihood(self, value):\n        \"\"\"Compute the loglikelihood based on the prior.\"\"\"\n        return self.loglikelihood_numerical_value(self._transformation(value))\n\n    def get_numerical_bounds(self):\n        \"\"\"Translate the provided bounds into the numerical representation.\"\"\"\n        return self.transformed_bounds\n\n    @abc.abstractmethod\n    def check_value(self, value):\n        \"\"\"Checks if value is valid.\"\"\"\n\n    @staticmethod\n    def from_dict(json_dict):\n        parameter_class = json_dict[\"class_name\"]\n        module_str, class_str = parameter_class.rsplit(\".\", 1)\n        module = importlib.import_module(module_str)\n        parameter_class = getattr(module, class_str)\n\n        transformation = BaseTransformation.from_dict(json_dict[\"transformation\"])\n        prior = BasePrior.from_dict(json_dict[\"prior\"])\n\n        return parameter_class(\n            *json_dict[\"init_args\"],\n            **json_dict[\"init_kwargs\"],\n            transformation=transformation,\n            prior=prior,\n        )\n\n    def to_dict(self):\n        json_dict = {\n            \"class_name\": type(self).__module__ + \".\" + type(self).__qualname__,\n            \"init_args\": self._init_args,\n            \"init_kwargs\": copy.deepcopy(self._init_kwargs),\n            \"transformation\": self._transformation.to_dict(),\n            \"prior\": self._prior.to_dict(),\n        }\n        for key in [\"transformation\", \"prior\"]:\n            if key in json_dict[\"init_kwargs\"]:\n                del json_dict[\"init_kwargs\"][key]\n\n        return json_dict\n\n    def __eq__(self, other):\n        if not isinstance(other, type(self)):\n            return False\n        if self.name != other.name:\n            return False\n        return (self._prior == other._prior) and (\n            self._transformation == other._transformation\n        )\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.__init__","title":"<code>__init__(self, name, prior, transformation, is_continuous, is_ordered, num_values, inactive_numerical_value=nan)</code>  <code>special</code>","text":"<p>Initialize with options common to all parameters.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>prior</code> <code>BasePrior</code> <p>Defines the pdf from which random samples are drawn. Default (<code>None</code>) corresponds to a uniform prior. Note that the prior's bounds must match the transformation's output bounds.</p> required <code>transformation</code> <code>BaseTransformation</code> <p>Defines the transformation from the values to their numerical representation. Note that the transformation's output bounds must match the prior's bounds.</p> required <code>is_continuous</code> <code>bool</code> <p>Indicates whether this parameter varies continuously, i.e. is a <code>float</code>.</p> required <code>is_ordered</code> <code>bool</code> <p>Indicates whether this parameter has a natural ordering of it's values.</p> required <code>num_values</code> <code>Union[int, float]</code> <p>Number of possible values. For ordinal, categorical, and integer parameters, this equals the number of unique values. For continuous parameters, it equals np.inf (even though technically there is only a finite number of float values).</p> required <code>inactive_numerical_value</code> <code>Optional[float]</code> <p>Placeholder value for this parameter in case it is not active</p> <code>nan</code> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    prior: BasePrior,\n    transformation: BaseTransformation,\n    is_continuous: bool,\n    is_ordered: bool,\n    num_values: Union[int, float],\n    inactive_numerical_value: Optional[float] = np.nan,\n):\n    \"\"\"\n    Initialize with options common to all parameters.\n\n    Args:\n        name: Name of the parameter.\n        prior: Defines the pdf from which random samples are drawn. Default (`None`)\n            corresponds to a uniform prior. Note that the prior's bounds must match\n            the transformation's output bounds.\n        transformation: Defines the transformation from the values to their\n            numerical representation. Note that the transformation's output bounds\n            must match the prior's bounds.\n        is_continuous: Indicates whether this parameter varies continuously, i.e.\n            is a `float`.\n        is_ordered: Indicates whether this parameter has a natural ordering of it's\n            values.\n        num_values: Number of possible values. For ordinal, categorical, and integer\n            parameters, this equals the number of unique values. For continuous\n            parameters, it equals np.inf (even though technically there is only a\n            finite number of float values).\n        inactive_numerical_value: Placeholder value for this parameter in case it\n            is not active\n    \"\"\"\n    if not is_valid_python_variable_name(name):\n        raise ValueError(f\"{name} needs to be a valid Python variable name.\")\n\n    self.name = name\n    self._prior = prior\n    self._transformation = transformation\n    self._inactive_numerical_value = inactive_numerical_value\n    self.transformed_bounds = self._transformation.output_bounds\n\n    self._init_args: Tuple\n    self._init_kwargs: Dict\n\n    assert np.allclose(self._prior.bounds, self.transformed_bounds, 1e-6), (\n        f\"Missmatch between the prior bounds ({self._prior.bounds})\"\n        + f\"and the transformation's bounds ({self.transformed_bounds})!\"\n    )\n\n    self.is_continuous = is_continuous\n    self.is_ordered = is_ordered\n    self.num_values = num_values\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Basic info about a parameter common to all types.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def __repr__(self):\n    \"\"\"Basic info about a parameter common to all types.\"\"\"\n    string = f\"Name: {self.name}\\n\"\n    string += f\"Type: {self.__class__}\\n\"\n    string += f\"Prior: {self._prior.__repr__()}\\n\"\n    string += f\"is continuous: {self.is_continuous}\\n\"\n    string += f\"is ordered: {self.is_ordered}\\n\"\n    string += f\"num_values: {self.num_values}\\n\"\n    return string\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.check_numerical_value","title":"<code>check_numerical_value(self, numerical_value)</code>","text":"<p>Check if the numerical representation of the value is valid.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def check_numerical_value(self, numerical_value):\n    \"\"\"Check if the numerical representation of the value is valid.\"\"\"\n    return (\n        self.transformed_bounds[0] &lt;= numerical_value &lt;= self.transformed_bounds[1]\n    )\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.check_value","title":"<code>check_value(self, value)</code>","text":"<p>Checks if value is valid.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>@abc.abstractmethod\ndef check_value(self, value):\n    \"\"\"Checks if value is valid.\"\"\"\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.get_numerical_bounds","title":"<code>get_numerical_bounds(self)</code>","text":"<p>Translate the provided bounds into the numerical representation.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def get_numerical_bounds(self):\n    \"\"\"Translate the provided bounds into the numerical representation.\"\"\"\n    return self.transformed_bounds\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.loglikelihood","title":"<code>loglikelihood(self, value)</code>","text":"<p>Compute the loglikelihood based on the prior.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def loglikelihood(self, value):\n    \"\"\"Compute the loglikelihood based on the prior.\"\"\"\n    return self.loglikelihood_numerical_value(self._transformation(value))\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.loglikelihood_numerical_value","title":"<code>loglikelihood_numerical_value(self, numerical_value)</code>","text":"<p>Compute the loglikelihood based on the prior.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def loglikelihood_numerical_value(self, numerical_value):\n    \"\"\"Compute the loglikelihood based on the prior.\"\"\"\n    return self._prior.loglikelihood(numerical_value) + np.log(\n        self._transformation.jacobian_factor(numerical_value)\n    )\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.num2val","title":"<code>num2val(self, numerical_value)</code>","text":"<p>Translate the numerical representation into the actual value.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def num2val(self, numerical_value):\n    \"\"\"Translate the numerical representation into the actual value.\"\"\"\n    return self._transformation.inverse(numerical_value)\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.pdf_numerical_value","title":"<code>pdf_numerical_value(self, numerical_value)</code>","text":"<p>Compute the PDF based on the prior.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def pdf_numerical_value(self, numerical_value):\n    \"\"\"Compute the PDF based on the prior.\"\"\"\n    return self._prior.pdf(numerical_value) * self._transformation.jacobian_factor(\n        numerical_value\n    )\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.sample_numerical_values","title":"<code>sample_numerical_values(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Generate random values based on the prior, but in the transformed space.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def sample_numerical_values(self, num_samples=None, random_state=np.random):\n    \"\"\"Generate random values based on the prior, but in the transformed space.\"\"\"\n    return self._prior.sample(num_samples, random_state=random_state)\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.sample_values","title":"<code>sample_values(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Generate randomly sampled values based on the prior.</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def sample_values(self, num_samples=None, random_state=np.random):\n    \"\"\"Generate randomly sampled values based on the prior.\"\"\"\n    numerical_samples = self.sample_numerical_values(num_samples, random_state)\n    if num_samples is None:\n        return self._transformation.inverse(numerical_samples)\n    return [\n        self._transformation.inverse(num_value) for num_value in numerical_samples\n    ]\n</code></pre>"},{"location":"API-Reference/parameters/base/#parameterspace.parameters.base.BaseParameter.val2num","title":"<code>val2num(self, value)</code>","text":"<p>Translate a value into its numerical representation (incl. normalization).</p> Source code in <code>parameterspace/parameters/base.py</code> <pre><code>def val2num(self, value):\n    \"\"\"Translate a value into its numerical representation (incl. normalization).\"\"\"\n    if value is None:\n        return self._inactive_numerical_value\n    return self._transformation(value)\n</code></pre>"},{"location":"API-Reference/parameters/categorical/","title":"Categorical","text":""},{"location":"API-Reference/parameters/categorical/#parameterspace.parameters.categorical.CategoricalParameter","title":"<code> CategoricalParameter            (BaseParameter)         </code>","text":"<p>Categorical parameter that can take discrete values of any type.</p> Source code in <code>parameterspace/parameters/categorical.py</code> <pre><code>class CategoricalParameter(BaseParameter):\n    \"\"\"Categorical parameter that can take discrete values of any type.\"\"\"\n\n    @store_init_arguments\n    # pylint: disable-next=too-many-positional-arguments\n    def __init__(\n        self,\n        name: str,\n        values: Tuple[Any, ...],\n        prior: Union[list, np.ndarray, None] = None,\n        transformation: Optional[BaseTransformation] = None,\n        inactive_numerical_value: Optional[float] = np.nan,\n    ):\n        \"\"\"\n        Initialize with options for categorical parameter.\n\n        Args:\n            name: Name of the parameter.\n            values: Allowed values for this parameter.\n            prior: Probabilities for each value (does not need to be normalized).\n            transformation: A transformation that can translate the arbitrary type of\n                the values to a numerical value. The only supported one right now\n                is [parameterspace.transformations.categorical.Cat2Num][], which is\n                also used as default.\n            inactive_numerical_value: [description]\n        \"\"\"\n        self.values = values\n        transformation = Cat2Num(values) if transformation is None else transformation\n\n        if prior is None:\n            _prior = Categorical([1.0] * len(values))\n        elif not isinstance(prior, Categorical):\n            _prior = Categorical(prior)\n        else:\n            _prior = prior\n\n        super().__init__(\n            name,\n            _prior,\n            transformation,\n            is_continuous=False,\n            is_ordered=False,\n            num_values=len(values),\n            inactive_numerical_value=inactive_numerical_value,\n        )\n\n    def check_value(self, value):\n        \"\"\"Check if value is valid.\"\"\"\n        return value in self.values\n</code></pre>"},{"location":"API-Reference/parameters/categorical/#parameterspace.parameters.categorical.CategoricalParameter.__init__","title":"<code>__init__(self, name, values, prior=None, transformation=None, inactive_numerical_value=nan)</code>  <code>special</code>","text":"<p>Initialize with options for categorical parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>values</code> <code>Tuple[Any, ...]</code> <p>Allowed values for this parameter.</p> required <code>prior</code> <code>Union[list, numpy.ndarray]</code> <p>Probabilities for each value (does not need to be normalized).</p> <code>None</code> <code>transformation</code> <code>Optional[parameterspace.transformations.base.BaseTransformation]</code> <p>A transformation that can translate the arbitrary type of the values to a numerical value. The only supported one right now is parameterspace.transformations.categorical.Cat2Num, which is also used as default.</p> <code>None</code> <code>inactive_numerical_value</code> <code>Optional[float]</code> <p>[description]</p> <code>nan</code> Source code in <code>parameterspace/parameters/categorical.py</code> <pre><code>@store_init_arguments\n# pylint: disable-next=too-many-positional-arguments\ndef __init__(\n    self,\n    name: str,\n    values: Tuple[Any, ...],\n    prior: Union[list, np.ndarray, None] = None,\n    transformation: Optional[BaseTransformation] = None,\n    inactive_numerical_value: Optional[float] = np.nan,\n):\n    \"\"\"\n    Initialize with options for categorical parameter.\n\n    Args:\n        name: Name of the parameter.\n        values: Allowed values for this parameter.\n        prior: Probabilities for each value (does not need to be normalized).\n        transformation: A transformation that can translate the arbitrary type of\n            the values to a numerical value. The only supported one right now\n            is [parameterspace.transformations.categorical.Cat2Num][], which is\n            also used as default.\n        inactive_numerical_value: [description]\n    \"\"\"\n    self.values = values\n    transformation = Cat2Num(values) if transformation is None else transformation\n\n    if prior is None:\n        _prior = Categorical([1.0] * len(values))\n    elif not isinstance(prior, Categorical):\n        _prior = Categorical(prior)\n    else:\n        _prior = prior\n\n    super().__init__(\n        name,\n        _prior,\n        transformation,\n        is_continuous=False,\n        is_ordered=False,\n        num_values=len(values),\n        inactive_numerical_value=inactive_numerical_value,\n    )\n</code></pre>"},{"location":"API-Reference/parameters/categorical/#parameterspace.parameters.categorical.CategoricalParameter.check_value","title":"<code>check_value(self, value)</code>","text":"<p>Check if value is valid.</p> Source code in <code>parameterspace/parameters/categorical.py</code> <pre><code>def check_value(self, value):\n    \"\"\"Check if value is valid.\"\"\"\n    return value in self.values\n</code></pre>"},{"location":"API-Reference/parameters/continuous/","title":"Continuous","text":""},{"location":"API-Reference/parameters/continuous/#parameterspace.parameters.continuous.ContinuousParameter","title":"<code> ContinuousParameter            (BaseParameter)         </code>","text":"<p>Continuous parameter represented by a float in a given range.</p> Source code in <code>parameterspace/parameters/continuous.py</code> <pre><code>class ContinuousParameter(BaseParameter):\n    \"\"\"Continuous parameter represented by a float in a given range.\"\"\"\n\n    @store_init_arguments\n    def __init__(\n        self,\n        name: str,\n        bounds: Tuple[float, float],\n        *,\n        prior: Optional[BasePrior] = None,\n        transformation: Union[BaseTransformation, str, None] = None,\n        inactive_numerical_value: Optional[float] = np.nan,\n    ):\n        \"\"\"\n        Initialize with options for continuous parameter.\n\n        Args:\n            name: Name of the parameter.\n            bounds: Lower and upper bound for the parameter.\n            prior: Default prior is the Uniform prior which will fail if at least one\n                of the bounds is infinite!\n            transformation: Default transformation is the affine-linear transformation\n                of the bounds to `[0,1]`. If a string is given, the transform is created\n                automatically for supported transforms.\n            inactive_numerical_value:  Placeholder value for this parameter in case\n                it is not active.\n        \"\"\"\n        if not np.isfinite(bounds).all():\n            raise ValueError(f\"Bounds need to be finite, but are {bounds}\")\n\n        self.bounds = np.array(bounds)\n\n        if not isinstance(transformation, BaseTransformation):\n            if transformation is None:\n                transformation = ZeroOneFloat(self.bounds)\n            elif transformation == \"log\":\n                transformation = LogZeroOneFloat(self.bounds)\n\n        prior = Uniform() if prior is None else prior\n        super().__init__(\n            name,\n            prior,\n            transformation,\n            is_continuous=True,\n            is_ordered=True,\n            num_values=np.inf,\n            inactive_numerical_value=inactive_numerical_value,\n        )\n\n    def __repr__(self):\n        \"\"\"Add bounds to the string representation.\"\"\"\n        string = super().__repr__()\n        string += f\"Bounds: ({self.bounds[0]}, {self.bounds[1]})\\n\"\n        return string\n\n    def check_value(self, value):\n        \"\"\"Check if value is valid.\"\"\"\n        return self.bounds[0] &lt;= value &lt;= self.bounds[1]\n</code></pre>"},{"location":"API-Reference/parameters/continuous/#parameterspace.parameters.continuous.ContinuousParameter.__init__","title":"<code>__init__(self, name, bounds, *, prior=None, transformation=None, inactive_numerical_value=nan)</code>  <code>special</code>","text":"<p>Initialize with options for continuous parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>bounds</code> <code>Tuple[float, float]</code> <p>Lower and upper bound for the parameter.</p> required <code>prior</code> <code>Optional[parameterspace.priors.base.BasePrior]</code> <p>Default prior is the Uniform prior which will fail if at least one of the bounds is infinite!</p> <code>None</code> <code>transformation</code> <code>Union[parameterspace.transformations.base.BaseTransformation, str]</code> <p>Default transformation is the affine-linear transformation of the bounds to <code>[0,1]</code>. If a string is given, the transform is created automatically for supported transforms.</p> <code>None</code> <code>inactive_numerical_value</code> <code>Optional[float]</code> <p>Placeholder value for this parameter in case it is not active.</p> <code>nan</code> Source code in <code>parameterspace/parameters/continuous.py</code> <pre><code>@store_init_arguments\ndef __init__(\n    self,\n    name: str,\n    bounds: Tuple[float, float],\n    *,\n    prior: Optional[BasePrior] = None,\n    transformation: Union[BaseTransformation, str, None] = None,\n    inactive_numerical_value: Optional[float] = np.nan,\n):\n    \"\"\"\n    Initialize with options for continuous parameter.\n\n    Args:\n        name: Name of the parameter.\n        bounds: Lower and upper bound for the parameter.\n        prior: Default prior is the Uniform prior which will fail if at least one\n            of the bounds is infinite!\n        transformation: Default transformation is the affine-linear transformation\n            of the bounds to `[0,1]`. If a string is given, the transform is created\n            automatically for supported transforms.\n        inactive_numerical_value:  Placeholder value for this parameter in case\n            it is not active.\n    \"\"\"\n    if not np.isfinite(bounds).all():\n        raise ValueError(f\"Bounds need to be finite, but are {bounds}\")\n\n    self.bounds = np.array(bounds)\n\n    if not isinstance(transformation, BaseTransformation):\n        if transformation is None:\n            transformation = ZeroOneFloat(self.bounds)\n        elif transformation == \"log\":\n            transformation = LogZeroOneFloat(self.bounds)\n\n    prior = Uniform() if prior is None else prior\n    super().__init__(\n        name,\n        prior,\n        transformation,\n        is_continuous=True,\n        is_ordered=True,\n        num_values=np.inf,\n        inactive_numerical_value=inactive_numerical_value,\n    )\n</code></pre>"},{"location":"API-Reference/parameters/continuous/#parameterspace.parameters.continuous.ContinuousParameter.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Add bounds to the string representation.</p> Source code in <code>parameterspace/parameters/continuous.py</code> <pre><code>def __repr__(self):\n    \"\"\"Add bounds to the string representation.\"\"\"\n    string = super().__repr__()\n    string += f\"Bounds: ({self.bounds[0]}, {self.bounds[1]})\\n\"\n    return string\n</code></pre>"},{"location":"API-Reference/parameters/continuous/#parameterspace.parameters.continuous.ContinuousParameter.check_value","title":"<code>check_value(self, value)</code>","text":"<p>Check if value is valid.</p> Source code in <code>parameterspace/parameters/continuous.py</code> <pre><code>def check_value(self, value):\n    \"\"\"Check if value is valid.\"\"\"\n    return self.bounds[0] &lt;= value &lt;= self.bounds[1]\n</code></pre>"},{"location":"API-Reference/parameters/integer/","title":"Integer","text":""},{"location":"API-Reference/parameters/integer/#parameterspace.parameters.integer.IntegerParameter","title":"<code> IntegerParameter            (BaseParameter)         </code>","text":"<p>Integer parameter that can take every integer value in a given range.</p> Source code in <code>parameterspace/parameters/integer.py</code> <pre><code>class IntegerParameter(BaseParameter):\n    \"\"\"Integer parameter that can take every integer value in a given range.\"\"\"\n\n    @store_init_arguments\n    def __init__(\n        self,\n        name: str,\n        bounds: Tuple,\n        *,\n        prior: Optional[BasePrior] = None,\n        transformation: Union[BaseTransformation, str, None] = None,\n        inactive_numerical_value: Optional[float] = np.nan,\n    ):\n        \"\"\"\n        Initialize with options for integer parameter.\n\n        Args:\n            name: Name of the parameter.\n            bounds: Lower and upper bound for the parameter.\n            prior: Default prior is the UniformInteger prior.\n            transformation: Default transformation is the affine-linear transformation\n                of the bounds to `[0,1]`. If a string is given, the transform is created\n                automatically for supported transforms.\n            inactive_numerical_value: Placeholder value for this parameter in case it\n                is not active.\n        \"\"\"\n        if not np.isfinite(bounds).all():\n            raise ValueError(f\"Bounds need to be finite, but are {bounds}\")\n\n        self.bounds = np.array(bounds, dtype=int)\n\n        if not isinstance(transformation, BaseTransformation):\n            if transformation is None:\n                transformation = ZeroOneInteger(self.bounds)\n            elif transformation == \"log\":\n                transformation = LogZeroOneInteger(self.bounds)\n\n        prior = Uniform() if prior is None else prior\n\n        super().__init__(\n            name,\n            prior,\n            transformation,\n            is_continuous=False,\n            is_ordered=True,\n            num_values=bounds[1] - bounds[0] + 1,\n            inactive_numerical_value=inactive_numerical_value,\n        )\n\n    def __repr__(self):\n        \"\"\"Add bounds to the string representation.\"\"\"\n        string = super().__repr__()\n        string += f\"Bounds: ({self.bounds[0]}, {self.bounds[1]})\\n\"\n        return string\n\n    def check_value(self, value):\n        \"\"\"Check if value is valid.\"\"\"\n        return self.bounds[0] &lt;= value &lt;= self.bounds[1] and value == int(value)\n\n    def num2val(self, numerical_value):\n        \"\"\"Translate the numerical representation into the actual value.\"\"\"\n        return int(super().num2val(numerical_value))\n</code></pre>"},{"location":"API-Reference/parameters/integer/#parameterspace.parameters.integer.IntegerParameter.__init__","title":"<code>__init__(self, name, bounds, *, prior=None, transformation=None, inactive_numerical_value=nan)</code>  <code>special</code>","text":"<p>Initialize with options for integer parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>bounds</code> <code>Tuple</code> <p>Lower and upper bound for the parameter.</p> required <code>prior</code> <code>Optional[parameterspace.priors.base.BasePrior]</code> <p>Default prior is the UniformInteger prior.</p> <code>None</code> <code>transformation</code> <code>Union[parameterspace.transformations.base.BaseTransformation, str]</code> <p>Default transformation is the affine-linear transformation of the bounds to <code>[0,1]</code>. If a string is given, the transform is created automatically for supported transforms.</p> <code>None</code> <code>inactive_numerical_value</code> <code>Optional[float]</code> <p>Placeholder value for this parameter in case it is not active.</p> <code>nan</code> Source code in <code>parameterspace/parameters/integer.py</code> <pre><code>@store_init_arguments\ndef __init__(\n    self,\n    name: str,\n    bounds: Tuple,\n    *,\n    prior: Optional[BasePrior] = None,\n    transformation: Union[BaseTransformation, str, None] = None,\n    inactive_numerical_value: Optional[float] = np.nan,\n):\n    \"\"\"\n    Initialize with options for integer parameter.\n\n    Args:\n        name: Name of the parameter.\n        bounds: Lower and upper bound for the parameter.\n        prior: Default prior is the UniformInteger prior.\n        transformation: Default transformation is the affine-linear transformation\n            of the bounds to `[0,1]`. If a string is given, the transform is created\n            automatically for supported transforms.\n        inactive_numerical_value: Placeholder value for this parameter in case it\n            is not active.\n    \"\"\"\n    if not np.isfinite(bounds).all():\n        raise ValueError(f\"Bounds need to be finite, but are {bounds}\")\n\n    self.bounds = np.array(bounds, dtype=int)\n\n    if not isinstance(transformation, BaseTransformation):\n        if transformation is None:\n            transformation = ZeroOneInteger(self.bounds)\n        elif transformation == \"log\":\n            transformation = LogZeroOneInteger(self.bounds)\n\n    prior = Uniform() if prior is None else prior\n\n    super().__init__(\n        name,\n        prior,\n        transformation,\n        is_continuous=False,\n        is_ordered=True,\n        num_values=bounds[1] - bounds[0] + 1,\n        inactive_numerical_value=inactive_numerical_value,\n    )\n</code></pre>"},{"location":"API-Reference/parameters/integer/#parameterspace.parameters.integer.IntegerParameter.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Add bounds to the string representation.</p> Source code in <code>parameterspace/parameters/integer.py</code> <pre><code>def __repr__(self):\n    \"\"\"Add bounds to the string representation.\"\"\"\n    string = super().__repr__()\n    string += f\"Bounds: ({self.bounds[0]}, {self.bounds[1]})\\n\"\n    return string\n</code></pre>"},{"location":"API-Reference/parameters/integer/#parameterspace.parameters.integer.IntegerParameter.check_value","title":"<code>check_value(self, value)</code>","text":"<p>Check if value is valid.</p> Source code in <code>parameterspace/parameters/integer.py</code> <pre><code>def check_value(self, value):\n    \"\"\"Check if value is valid.\"\"\"\n    return self.bounds[0] &lt;= value &lt;= self.bounds[1] and value == int(value)\n</code></pre>"},{"location":"API-Reference/parameters/integer/#parameterspace.parameters.integer.IntegerParameter.num2val","title":"<code>num2val(self, numerical_value)</code>","text":"<p>Translate the numerical representation into the actual value.</p> Source code in <code>parameterspace/parameters/integer.py</code> <pre><code>def num2val(self, numerical_value):\n    \"\"\"Translate the numerical representation into the actual value.\"\"\"\n    return int(super().num2val(numerical_value))\n</code></pre>"},{"location":"API-Reference/parameters/ordinal/","title":"Ordinal","text":""},{"location":"API-Reference/parameters/ordinal/#parameterspace.parameters.ordinal.OrdinalParameter","title":"<code> OrdinalParameter            (BaseParameter)         </code>","text":"<p>Ordinal parameter that can take discrete values of any type.</p> Source code in <code>parameterspace/parameters/ordinal.py</code> <pre><code>class OrdinalParameter(BaseParameter):\n    \"\"\"Ordinal parameter that can take discrete values of any type.\"\"\"\n\n    @store_init_arguments\n    def __init__(\n        self,\n        name: str,\n        values: list,\n        *,\n        prior: Union[list, np.ndarray, None] = None,\n        transformation: Optional[BaseTransformation] = None,\n        inactive_numerical_value: Optional[float] = np.nan\n    ):\n        \"\"\"\n        Initialize with options for ordinal parameter.\n\n        Args:\n            name: Name of the parameter.\n            values: Allowed values in ascending order for this parameter.\n            prior: List of (unnormalized) probablities for each value.\n                Default puts equal probablity for each value.\n            transformation: The only supported transformation right now\n                is [parameterspace.transformations.categorical.Cat2Num][],\n                which is also the default.\n            inactive_numerical_value: Placeholder value for this parameter\n                in case it is not active. Default is NaN.\n        \"\"\"\n        self.values = values\n        transformation = Cat2Num(values) if transformation is None else transformation\n        prior = Uniform() if prior is None else prior\n        super().__init__(\n            name,\n            prior,\n            transformation,\n            is_continuous=False,\n            is_ordered=True,\n            num_values=len(values),\n            inactive_numerical_value=inactive_numerical_value,\n        )\n\n    def check_value(self, value):\n        \"\"\"Check if value is valid.\"\"\"\n        return value in self.values\n</code></pre>"},{"location":"API-Reference/parameters/ordinal/#parameterspace.parameters.ordinal.OrdinalParameter.__init__","title":"<code>__init__(self, name, values, *, prior=None, transformation=None, inactive_numerical_value=nan)</code>  <code>special</code>","text":"<p>Initialize with options for ordinal parameter.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the parameter.</p> required <code>values</code> <code>list</code> <p>Allowed values in ascending order for this parameter.</p> required <code>prior</code> <code>Union[list, numpy.ndarray]</code> <p>List of (unnormalized) probablities for each value. Default puts equal probablity for each value.</p> <code>None</code> <code>transformation</code> <code>Optional[parameterspace.transformations.base.BaseTransformation]</code> <p>The only supported transformation right now is parameterspace.transformations.categorical.Cat2Num, which is also the default.</p> <code>None</code> <code>inactive_numerical_value</code> <code>Optional[float]</code> <p>Placeholder value for this parameter in case it is not active. Default is NaN.</p> <code>nan</code> Source code in <code>parameterspace/parameters/ordinal.py</code> <pre><code>@store_init_arguments\ndef __init__(\n    self,\n    name: str,\n    values: list,\n    *,\n    prior: Union[list, np.ndarray, None] = None,\n    transformation: Optional[BaseTransformation] = None,\n    inactive_numerical_value: Optional[float] = np.nan\n):\n    \"\"\"\n    Initialize with options for ordinal parameter.\n\n    Args:\n        name: Name of the parameter.\n        values: Allowed values in ascending order for this parameter.\n        prior: List of (unnormalized) probablities for each value.\n            Default puts equal probablity for each value.\n        transformation: The only supported transformation right now\n            is [parameterspace.transformations.categorical.Cat2Num][],\n            which is also the default.\n        inactive_numerical_value: Placeholder value for this parameter\n            in case it is not active. Default is NaN.\n    \"\"\"\n    self.values = values\n    transformation = Cat2Num(values) if transformation is None else transformation\n    prior = Uniform() if prior is None else prior\n    super().__init__(\n        name,\n        prior,\n        transformation,\n        is_continuous=False,\n        is_ordered=True,\n        num_values=len(values),\n        inactive_numerical_value=inactive_numerical_value,\n    )\n</code></pre>"},{"location":"API-Reference/parameters/ordinal/#parameterspace.parameters.ordinal.OrdinalParameter.check_value","title":"<code>check_value(self, value)</code>","text":"<p>Check if value is valid.</p> Source code in <code>parameterspace/parameters/ordinal.py</code> <pre><code>def check_value(self, value):\n    \"\"\"Check if value is valid.\"\"\"\n    return value in self.values\n</code></pre>"},{"location":"API-Reference/priors/base/","title":"Base","text":""},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior","title":"<code> BasePrior            (ABC)         </code>","text":"<p>Base class defining the API of the priors.</p> <p>The priors enable the incorporation of domain knowledge into the parameter definition by allowing the specification of a PDF/PMF. These are used to sample random values and to compute the loglikelihood of a given value.</p> Source code in <code>parameterspace/priors/base.py</code> <pre><code>class BasePrior(abc.ABC):\n    \"\"\"Base class defining the API of the priors.\n\n    The priors enable the incorporation of domain knowledge into the parameter\n    definition by allowing the specification of a PDF/PMF. These are used to sample\n    random values and to compute the loglikelihood of a given value.\n    \"\"\"\n\n    def __init__(self, bounds: Tuple):\n        \"\"\"\n        Args:\n            bounds: Lower and upper bound of the prior.\n        \"\"\"\n        self._init_args: Tuple\n        self._init_kwargs: Dict\n        self.bounds = np.array(bounds, dtype=float)\n\n    def loglikelihood(self, value):\n        \"\"\"\n        Compute the log PDF (up to an additive constant) of a given value.\n\n        Note:\n            Values for the priors are always after the transformation!\n\n        Args:\n            value: [description]\n\n        Returns:\n            [descriptions]\n        \"\"\"\n        return np.log(self.pdf(value))\n\n    @abc.abstractmethod\n    def pdf(self, value):\n        \"\"\"\n        Computes the PDF of a given value.\n\n        Note:\n            Values for the priors are always after the transformation!\n\n        Args:\n            value: [description]\n\n        Returns:\n            [descriptions]\n        \"\"\"\n\n    @abc.abstractmethod\n    def sample(self, num_samples: int = 1):\n        \"\"\"\n        Draw random samples from the prior.\n\n        Args:\n            num_samples: [description]\n\n        Returns:\n            [descriptions]\n        \"\"\"\n\n    @staticmethod\n    def from_dict(json_dict):\n        prior_class = json_dict[\"class_name\"]\n        module_str, class_str = prior_class.rsplit(\".\", 1)\n        module = importlib.import_module(module_str)\n        model_class = getattr(module, class_str)\n        return model_class(*json_dict[\"init_args\"], **json_dict[\"init_kwargs\"])\n\n    def to_dict(self):\n        json_dict = {\n            \"class_name\": type(self).__module__ + \".\" + type(self).__qualname__,\n            \"init_args\": self._init_args,\n            \"init_kwargs\": self._init_kwargs,\n        }\n        return json_dict\n\n    def __eq__(self, other):\n        \"\"\"Uniform prior doesn't have a state, so equality is just class membership.\"\"\"\n        return isinstance(other, type(self))\n</code></pre>"},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior.__eq__","title":"<code>__eq__(self, other)</code>  <code>special</code>","text":"<p>Uniform prior doesn't have a state, so equality is just class membership.</p> Source code in <code>parameterspace/priors/base.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Uniform prior doesn't have a state, so equality is just class membership.\"\"\"\n    return isinstance(other, type(self))\n</code></pre>"},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior.__init__","title":"<code>__init__(self, bounds)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Tuple</code> <p>Lower and upper bound of the prior.</p> required Source code in <code>parameterspace/priors/base.py</code> <pre><code>def __init__(self, bounds: Tuple):\n    \"\"\"\n    Args:\n        bounds: Lower and upper bound of the prior.\n    \"\"\"\n    self._init_args: Tuple\n    self._init_kwargs: Dict\n    self.bounds = np.array(bounds, dtype=float)\n</code></pre>"},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior.loglikelihood","title":"<code>loglikelihood(self, value)</code>","text":"<p>Compute the log PDF (up to an additive constant) of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/base.py</code> <pre><code>def loglikelihood(self, value):\n    \"\"\"\n    Compute the log PDF (up to an additive constant) of a given value.\n\n    Note:\n        Values for the priors are always after the transformation!\n\n    Args:\n        value: [description]\n\n    Returns:\n        [descriptions]\n    \"\"\"\n    return np.log(self.pdf(value))\n</code></pre>"},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior.pdf","title":"<code>pdf(self, value)</code>","text":"<p>Computes the PDF of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/base.py</code> <pre><code>@abc.abstractmethod\ndef pdf(self, value):\n    \"\"\"\n    Computes the PDF of a given value.\n\n    Note:\n        Values for the priors are always after the transformation!\n\n    Args:\n        value: [description]\n\n    Returns:\n        [descriptions]\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/priors/base/#parameterspace.priors.base.BasePrior.sample","title":"<code>sample(self, num_samples=1)</code>","text":"<p>Draw random samples from the prior.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <code>int</code> <p>[description]</p> <code>1</code> <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/base.py</code> <pre><code>@abc.abstractmethod\ndef sample(self, num_samples: int = 1):\n    \"\"\"\n    Draw random samples from the prior.\n\n    Args:\n        num_samples: [description]\n\n    Returns:\n        [descriptions]\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/priors/beta/","title":"Beta","text":""},{"location":"API-Reference/priors/beta/#parameterspace.priors.beta.Beta","title":"<code> Beta            (BasePrior)         </code>","text":"<p>Beta prior for variables in the interval [0,1].</p> Source code in <code>parameterspace/priors/beta.py</code> <pre><code>class Beta(BasePrior):\n    \"\"\"Beta prior for variables in the interval [0,1].\"\"\"\n\n    @store_init_arguments\n    def __init__(self, a: float, b: float):\n        \"\"\"\n        Args:\n            a: Positive parameter of the Beta distribution.\n            b: Positive parameter of the Beta distribution.\n        \"\"\"\n        super().__init__((0, 1))\n        self.a, self.b = a, b\n        self.sps_beta_dist = sps.beta(a, b)\n\n    def pdf(self, value):\n        return self.sps_beta_dist.pdf(value)\n\n    def loglikelihood(self, value):\n        return self.sps_beta_dist.logpdf(value)\n\n    def sample(self, num_samples=None, random_state=np.random):\n        return self.sps_beta_dist.rvs(size=num_samples, random_state=random_state)\n\n    def __repr__(self):\n        return f\"Beta distribution with parameters a={self.a}, b={self.b}\"\n\n    def __eq__(self, other):\n        return super().__eq__(other) and np.allclose(\n            [self.a, self.b], [other.a, other.b]\n        )\n</code></pre>"},{"location":"API-Reference/priors/beta/#parameterspace.priors.beta.Beta.__init__","title":"<code>__init__(self, a, b)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>Positive parameter of the Beta distribution.</p> required <code>b</code> <code>float</code> <p>Positive parameter of the Beta distribution.</p> required Source code in <code>parameterspace/priors/beta.py</code> <pre><code>@store_init_arguments\ndef __init__(self, a: float, b: float):\n    \"\"\"\n    Args:\n        a: Positive parameter of the Beta distribution.\n        b: Positive parameter of the Beta distribution.\n    \"\"\"\n    super().__init__((0, 1))\n    self.a, self.b = a, b\n    self.sps_beta_dist = sps.beta(a, b)\n</code></pre>"},{"location":"API-Reference/priors/beta/#parameterspace.priors.beta.Beta.loglikelihood","title":"<code>loglikelihood(self, value)</code>","text":"<p>Compute the log PDF (up to an additive constant) of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/beta.py</code> <pre><code>def loglikelihood(self, value):\n    return self.sps_beta_dist.logpdf(value)\n</code></pre>"},{"location":"API-Reference/priors/beta/#parameterspace.priors.beta.Beta.pdf","title":"<code>pdf(self, value)</code>","text":"<p>Computes the PDF of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/beta.py</code> <pre><code>def pdf(self, value):\n    return self.sps_beta_dist.pdf(value)\n</code></pre>"},{"location":"API-Reference/priors/beta/#parameterspace.priors.beta.Beta.sample","title":"<code>sample(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Draw random samples from the prior.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <p>[description]</p> <code>None</code> <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/beta.py</code> <pre><code>def sample(self, num_samples=None, random_state=np.random):\n    return self.sps_beta_dist.rvs(size=num_samples, random_state=random_state)\n</code></pre>"},{"location":"API-Reference/priors/categorical/","title":"Categorical","text":""},{"location":"API-Reference/priors/categorical/#parameterspace.priors.categorical.Categorical","title":"<code> Categorical            (BasePrior)         </code>","text":"<p>Categorical prior with separate probabilities for each value.</p> Source code in <code>parameterspace/priors/categorical.py</code> <pre><code>class Categorical(BasePrior):\n    \"\"\"Categorical prior with separate probabilities for each value.\"\"\"\n\n    @store_init_arguments\n    def __init__(self, prior_values: Union[list, np.ndarray]):\n        \"\"\"\n        Args:\n            prior_values: Array containing the probabilities for each value.\n        \"\"\"\n        super().__init__((0, 1))\n        self.probabilities = np.array(prior_values)\n        if not np.all(self.probabilities &gt;= 0):\n            raise ValueError(\"Probabilities must be non-negative!\")\n\n        self.probabilities = self.probabilities / np.sum(self.probabilities)\n        self.numerical_values = (\n            np.arange(len(self.probabilities), dtype=float) + 0.5\n        ) / len(self.probabilities)\n\n    def loglikelihood(self, value):\n        return np.log(self.pdf(value))\n\n    def pdf(self, value):\n        \"\"\"Probability given the numerical representation(s).\n\n        The numerical representation is converted to integers and the corresponding\n        prior_values are returned.\n        If the value exceeds the given range of values, a ValueError is raised.\n\n        Only finite values are converted, and the respective probability is computed.\n        NaN and INF will result in a NaN. For example:\n            value = [nan, inf, 0]\n        will result in\n            [NaN, NaN, p(0)].\n\n        \"\"\"\n        value = np.atleast_1d(value)\n        idx = np.isfinite(value)\n\n        integer_value = np.around(len(self.probabilities) * value[idx] - 0.5).astype(\n            int\n        )\n        pdf = np.full(value.shape, np.nan, dtype=float)\n\n        try:\n            pdf[idx] = self.probabilities[integer_value]\n        except IndexError as e:\n            raise ValueError(\n                \"Unknown value in the numerical representation for a \"\n                + \"categorical parameter encountered!\"\n            ) from e\n        return pdf.squeeze()\n\n    def sample(self, num_samples=None, random_state=np.random):\n        return random_state.choice(\n            self.numerical_values, size=num_samples, replace=True, p=self.probabilities\n        )\n\n    def __repr__(self):\n        return (\n            f\"Categorical prior for {len(self.probabilities)} values \"\n            + f\"with p = {self.probabilities}\"\n        )\n\n    def __eq__(self, other):\n        return (\n            super().__eq__(other)\n            and (len(self.probabilities) == len(other.probabilities))\n            and np.allclose(self.probabilities, other.probabilities)\n        )\n</code></pre>"},{"location":"API-Reference/priors/categorical/#parameterspace.priors.categorical.Categorical.__init__","title":"<code>__init__(self, prior_values)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>prior_values</code> <code>Union[list, numpy.ndarray]</code> <p>Array containing the probabilities for each value.</p> required Source code in <code>parameterspace/priors/categorical.py</code> <pre><code>@store_init_arguments\ndef __init__(self, prior_values: Union[list, np.ndarray]):\n    \"\"\"\n    Args:\n        prior_values: Array containing the probabilities for each value.\n    \"\"\"\n    super().__init__((0, 1))\n    self.probabilities = np.array(prior_values)\n    if not np.all(self.probabilities &gt;= 0):\n        raise ValueError(\"Probabilities must be non-negative!\")\n\n    self.probabilities = self.probabilities / np.sum(self.probabilities)\n    self.numerical_values = (\n        np.arange(len(self.probabilities), dtype=float) + 0.5\n    ) / len(self.probabilities)\n</code></pre>"},{"location":"API-Reference/priors/categorical/#parameterspace.priors.categorical.Categorical.loglikelihood","title":"<code>loglikelihood(self, value)</code>","text":"<p>Compute the log PDF (up to an additive constant) of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/categorical.py</code> <pre><code>def loglikelihood(self, value):\n    return np.log(self.pdf(value))\n</code></pre>"},{"location":"API-Reference/priors/categorical/#parameterspace.priors.categorical.Categorical.pdf","title":"<code>pdf(self, value)</code>","text":"<p>Probability given the numerical representation(s).</p> <p>The numerical representation is converted to integers and the corresponding prior_values are returned. If the value exceeds the given range of values, a ValueError is raised.</p> <p>Only finite values are converted, and the respective probability is computed. NaN and INF will result in a NaN. For example:     value = [nan, inf, 0] will result in     [NaN, NaN, p(0)].</p> Source code in <code>parameterspace/priors/categorical.py</code> <pre><code>def pdf(self, value):\n    \"\"\"Probability given the numerical representation(s).\n\n    The numerical representation is converted to integers and the corresponding\n    prior_values are returned.\n    If the value exceeds the given range of values, a ValueError is raised.\n\n    Only finite values are converted, and the respective probability is computed.\n    NaN and INF will result in a NaN. For example:\n        value = [nan, inf, 0]\n    will result in\n        [NaN, NaN, p(0)].\n\n    \"\"\"\n    value = np.atleast_1d(value)\n    idx = np.isfinite(value)\n\n    integer_value = np.around(len(self.probabilities) * value[idx] - 0.5).astype(\n        int\n    )\n    pdf = np.full(value.shape, np.nan, dtype=float)\n\n    try:\n        pdf[idx] = self.probabilities[integer_value]\n    except IndexError as e:\n        raise ValueError(\n            \"Unknown value in the numerical representation for a \"\n            + \"categorical parameter encountered!\"\n        ) from e\n    return pdf.squeeze()\n</code></pre>"},{"location":"API-Reference/priors/categorical/#parameterspace.priors.categorical.Categorical.sample","title":"<code>sample(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Draw random samples from the prior.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <p>[description]</p> <code>None</code> <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/categorical.py</code> <pre><code>def sample(self, num_samples=None, random_state=np.random):\n    return random_state.choice(\n        self.numerical_values, size=num_samples, replace=True, p=self.probabilities\n    )\n</code></pre>"},{"location":"API-Reference/priors/truncated_normal/","title":"Truncated normal","text":""},{"location":"API-Reference/priors/truncated_normal/#parameterspace.priors.truncated_normal.TruncatedNormal","title":"<code> TruncatedNormal            (BasePrior)         </code>","text":"<p>Truncated normal prior for bounded parameters.</p> Source code in <code>parameterspace/priors/truncated_normal.py</code> <pre><code>class TruncatedNormal(BasePrior):\n    \"\"\"Truncated normal prior for bounded parameters.\"\"\"\n\n    @store_init_arguments\n    def __init__(self, mean: float = 0.5, std: float = 1):\n        \"\"\"\n        Args:\n            mean: Mean of the distribution.\n            std: Standard deviation of the distribution\n        \"\"\"\n        super().__init__((0, 1))\n        a, b = (self.bounds - mean) / std\n        self.mean = mean\n        self.std = std\n        self.sps_dist = sps.truncnorm(a, b, loc=mean, scale=std)\n\n    def pdf(self, value):\n        return self.sps_dist.pdf(value)\n\n    def loglikelihood(self, value):\n        return self.sps_dist.logpdf(value)\n\n    def sample(self, num_samples=None, random_state=npr):\n        return self.sps_dist.rvs(size=num_samples, random_state=random_state)\n\n    def __repr__(self):\n        return (\n            f\"Truncated normal (Interval [{self.bounds[0]}, {self.bounds[1]}]) with \"\n            + f\"parameters mean={self.mean}, std={self.std}\"\n        )\n\n    def __eq__(self, other):\n        return super().__eq__(other) and np.allclose(\n            [self.mean, self.std], [other.mean, other.std]\n        )\n</code></pre>"},{"location":"API-Reference/priors/truncated_normal/#parameterspace.priors.truncated_normal.TruncatedNormal.__init__","title":"<code>__init__(self, mean=0.5, std=1)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>mean</code> <code>float</code> <p>Mean of the distribution.</p> <code>0.5</code> <code>std</code> <code>float</code> <p>Standard deviation of the distribution</p> <code>1</code> Source code in <code>parameterspace/priors/truncated_normal.py</code> <pre><code>@store_init_arguments\ndef __init__(self, mean: float = 0.5, std: float = 1):\n    \"\"\"\n    Args:\n        mean: Mean of the distribution.\n        std: Standard deviation of the distribution\n    \"\"\"\n    super().__init__((0, 1))\n    a, b = (self.bounds - mean) / std\n    self.mean = mean\n    self.std = std\n    self.sps_dist = sps.truncnorm(a, b, loc=mean, scale=std)\n</code></pre>"},{"location":"API-Reference/priors/truncated_normal/#parameterspace.priors.truncated_normal.TruncatedNormal.loglikelihood","title":"<code>loglikelihood(self, value)</code>","text":"<p>Compute the log PDF (up to an additive constant) of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/truncated_normal.py</code> <pre><code>def loglikelihood(self, value):\n    return self.sps_dist.logpdf(value)\n</code></pre>"},{"location":"API-Reference/priors/truncated_normal/#parameterspace.priors.truncated_normal.TruncatedNormal.pdf","title":"<code>pdf(self, value)</code>","text":"<p>Computes the PDF of a given value.</p> <p>Note</p> <p>Values for the priors are always after the transformation!</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>[description]</p> required <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/truncated_normal.py</code> <pre><code>def pdf(self, value):\n    return self.sps_dist.pdf(value)\n</code></pre>"},{"location":"API-Reference/priors/truncated_normal/#parameterspace.priors.truncated_normal.TruncatedNormal.sample","title":"<code>sample(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Draw random samples from the prior.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <p>[description]</p> <code>None</code> <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/truncated_normal.py</code> <pre><code>def sample(self, num_samples=None, random_state=npr):\n    return self.sps_dist.rvs(size=num_samples, random_state=random_state)\n</code></pre>"},{"location":"API-Reference/priors/uniform/","title":"Uniform","text":""},{"location":"API-Reference/priors/uniform/#parameterspace.priors.uniform.Uniform","title":"<code> Uniform            (BasePrior)         </code>","text":"<p>Uninformed prior that puts equal weight on every value.</p> Source code in <code>parameterspace/priors/uniform.py</code> <pre><code>class Uniform(BasePrior):\n    \"\"\"Uninformed prior that puts equal weight on every value.\"\"\"\n\n    @store_init_arguments\n    def __init__(self):\n        super().__init__([0, 1])\n\n    def pdf(self, value):\n        \"\"\"Calculate probability density function value.\n\n        Return constant for values inside the bounds, zero if outside, and NaN for NaNs.\n        \"\"\"\n        value = np.atleast_1d(value)\n        active_idx = np.isfinite(value)\n        pdf = np.full(value.shape, np.nan)\n        inside = np.logical_and(\n            self.bounds[0] &lt;= value[active_idx], value[active_idx] &lt;= self.bounds[1]\n        )\n        pdf[active_idx] = 1.0 / (self.bounds[1] - self.bounds[0]) * (inside)\n        return pdf.squeeze()\n\n    def sample(self, num_samples=None, random_state=np.random):\n        return random_state.uniform(\n            low=self.bounds[0], high=self.bounds[1], size=num_samples\n        )\n\n    def __repr__(self):\n        \"\"\"Minimal information about the Prior.\"\"\"\n        return f\"Uniform prior in the interval [{self.bounds[0]}, {self.bounds[1]}].\"\n</code></pre>"},{"location":"API-Reference/priors/uniform/#parameterspace.priors.uniform.Uniform.__repr__","title":"<code>__repr__(self)</code>  <code>special</code>","text":"<p>Minimal information about the Prior.</p> Source code in <code>parameterspace/priors/uniform.py</code> <pre><code>def __repr__(self):\n    \"\"\"Minimal information about the Prior.\"\"\"\n    return f\"Uniform prior in the interval [{self.bounds[0]}, {self.bounds[1]}].\"\n</code></pre>"},{"location":"API-Reference/priors/uniform/#parameterspace.priors.uniform.Uniform.pdf","title":"<code>pdf(self, value)</code>","text":"<p>Calculate probability density function value.</p> <p>Return constant for values inside the bounds, zero if outside, and NaN for NaNs.</p> Source code in <code>parameterspace/priors/uniform.py</code> <pre><code>def pdf(self, value):\n    \"\"\"Calculate probability density function value.\n\n    Return constant for values inside the bounds, zero if outside, and NaN for NaNs.\n    \"\"\"\n    value = np.atleast_1d(value)\n    active_idx = np.isfinite(value)\n    pdf = np.full(value.shape, np.nan)\n    inside = np.logical_and(\n        self.bounds[0] &lt;= value[active_idx], value[active_idx] &lt;= self.bounds[1]\n    )\n    pdf[active_idx] = 1.0 / (self.bounds[1] - self.bounds[0]) * (inside)\n    return pdf.squeeze()\n</code></pre>"},{"location":"API-Reference/priors/uniform/#parameterspace.priors.uniform.Uniform.sample","title":"<code>sample(self, num_samples=None, random_state=&lt;module 'numpy.random' from '/home/grl2rng/anaconda3/envs/py313/lib/python3.13/site-packages/numpy/random/__init__.py'&gt;)</code>","text":"<p>Draw random samples from the prior.</p> <p>Parameters:</p> Name Type Description Default <code>num_samples</code> <p>[description]</p> <code>None</code> <p>Returns:</p> Type Description <p>[descriptions]</p> Source code in <code>parameterspace/priors/uniform.py</code> <pre><code>def sample(self, num_samples=None, random_state=np.random):\n    return random_state.uniform(\n        low=self.bounds[0], high=self.bounds[1], size=num_samples\n    )\n</code></pre>"},{"location":"API-Reference/transformations/base/","title":"Base","text":""},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation","title":"<code> BaseTransformation            (ABC)         </code>","text":"<p>Base class defining the API of a transformation.</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>class BaseTransformation(abc.ABC):\n    \"\"\"Base class defining the API of a transformation.\"\"\"\n\n    def __init__(self, input_bounds: Optional[Tuple], output_bounds: Tuple):\n        \"\"\"\n        Args:\n            input_bounds: The numerical range for the input of a transformation. If\n                that is not applicable, e.g. for categorical parameters, use `None`.\n            output_bounds: The numerical range for the output of a transformation.\n                As every transformation yields a numerical representation, these\n                bounds have to be always specified in the form\n                [lower_bound, upper_bound].\n        \"\"\"\n        self._init_args: Tuple\n        self._init_kwargs: Dict\n        self.input_bounds = None if input_bounds is None else np.array(input_bounds)\n        self.output_bounds = np.array(output_bounds)\n\n    @abc.abstractmethod\n    def inverse(self, numerical_value: float) -&gt; Any:\n        \"\"\"Convert the numerical representation back to the true value with the proper\n        type.\n\n        Args:\n            numerical_value: Transformed/Numerical representation of a value.\n\n        Returns:\n            The value corresponding to the given value. Type depends no the kind of\n            transformation.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __call__(self, value: Any) -&gt; float:\n        \"\"\"Convert a value into the numerical representation.\n\n        Args:\n            value: A valid value for this transformation.\n\n        Returns:\n            Transformed/Numerical representation of the value.\n        \"\"\"\n\n    def jacobian_factor(\n        self, numerical_value: float  # pylint: disable=unused-argument\n    ) -&gt; float:\n        \"\"\"Factor to correct the likelihood based on the non-linear transformation.\n\n        Args:\n            numerical_value: Transformed/Numerical representation of a value.\n\n        Returns:\n            Jacobian factor to properly transform the likelihood.\n        \"\"\"\n        return 1.0\n\n    @staticmethod\n    def from_dict(json_dict: dict):\n        \"\"\"\n        [summary]\n        \"\"\"\n        transformation_class = json_dict[\"class_name\"]\n        module_str, class_str = transformation_class.rsplit(\".\", 1)\n        module = importlib.import_module(module_str)\n        model_class = getattr(module, class_str)\n        return model_class(*json_dict[\"init_args\"], **json_dict[\"init_kwargs\"])\n\n    def to_dict(self):\n        \"\"\"\n        [summary]\n        \"\"\"\n        json_dict = {\n            \"class_name\": type(self).__module__ + \".\" + type(self).__qualname__,\n            \"init_args\": self._init_args,\n            \"init_kwargs\": self._init_kwargs,\n        }\n        return json_dict\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.__call__","title":"<code>__call__(self, value)</code>  <code>special</code>","text":"<p>Convert a value into the numerical representation.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>A valid value for this transformation.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Transformed/Numerical representation of the value.</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>@abc.abstractmethod\ndef __call__(self, value: Any) -&gt; float:\n    \"\"\"Convert a value into the numerical representation.\n\n    Args:\n        value: A valid value for this transformation.\n\n    Returns:\n        Transformed/Numerical representation of the value.\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.__init__","title":"<code>__init__(self, input_bounds, output_bounds)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>input_bounds</code> <code>Optional[Tuple]</code> <p>The numerical range for the input of a transformation. If that is not applicable, e.g. for categorical parameters, use <code>None</code>.</p> required <code>output_bounds</code> <code>Tuple</code> <p>The numerical range for the output of a transformation. As every transformation yields a numerical representation, these bounds have to be always specified in the form [lower_bound, upper_bound].</p> required Source code in <code>parameterspace/transformations/base.py</code> <pre><code>def __init__(self, input_bounds: Optional[Tuple], output_bounds: Tuple):\n    \"\"\"\n    Args:\n        input_bounds: The numerical range for the input of a transformation. If\n            that is not applicable, e.g. for categorical parameters, use `None`.\n        output_bounds: The numerical range for the output of a transformation.\n            As every transformation yields a numerical representation, these\n            bounds have to be always specified in the form\n            [lower_bound, upper_bound].\n    \"\"\"\n    self._init_args: Tuple\n    self._init_kwargs: Dict\n    self.input_bounds = None if input_bounds is None else np.array(input_bounds)\n    self.output_bounds = np.array(output_bounds)\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.from_dict","title":"<code>from_dict(json_dict)</code>  <code>staticmethod</code>","text":"<p>[summary]</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>@staticmethod\ndef from_dict(json_dict: dict):\n    \"\"\"\n    [summary]\n    \"\"\"\n    transformation_class = json_dict[\"class_name\"]\n    module_str, class_str = transformation_class.rsplit(\".\", 1)\n    module = importlib.import_module(module_str)\n    model_class = getattr(module, class_str)\n    return model_class(*json_dict[\"init_args\"], **json_dict[\"init_kwargs\"])\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>Convert the numerical representation back to the true value with the proper type.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value corresponding to the given value. Type depends no the kind of transformation.</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>@abc.abstractmethod\ndef inverse(self, numerical_value: float) -&gt; Any:\n    \"\"\"Convert the numerical representation back to the true value with the proper\n    type.\n\n    Args:\n        numerical_value: Transformed/Numerical representation of a value.\n\n    Returns:\n        The value corresponding to the given value. Type depends no the kind of\n        transformation.\n    \"\"\"\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.jacobian_factor","title":"<code>jacobian_factor(self, numerical_value)</code>","text":"<p>Factor to correct the likelihood based on the non-linear transformation.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Jacobian factor to properly transform the likelihood.</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>def jacobian_factor(\n    self, numerical_value: float  # pylint: disable=unused-argument\n) -&gt; float:\n    \"\"\"Factor to correct the likelihood based on the non-linear transformation.\n\n    Args:\n        numerical_value: Transformed/Numerical representation of a value.\n\n    Returns:\n        Jacobian factor to properly transform the likelihood.\n    \"\"\"\n    return 1.0\n</code></pre>"},{"location":"API-Reference/transformations/base/#parameterspace.transformations.base.BaseTransformation.to_dict","title":"<code>to_dict(self)</code>","text":"<p>[summary]</p> Source code in <code>parameterspace/transformations/base.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    [summary]\n    \"\"\"\n    json_dict = {\n        \"class_name\": type(self).__module__ + \".\" + type(self).__qualname__,\n        \"init_args\": self._init_args,\n        \"init_kwargs\": self._init_kwargs,\n    }\n    return json_dict\n</code></pre>"},{"location":"API-Reference/transformations/categorical/","title":"Categorical","text":""},{"location":"API-Reference/transformations/categorical/#parameterspace.transformations.categorical.Cat2Num","title":"<code> Cat2Num            (BaseTransformation)         </code>","text":"<p>Translates any values into discrete, equidistant values between 0 and 1.</p> Source code in <code>parameterspace/transformations/categorical.py</code> <pre><code>class Cat2Num(BaseTransformation):\n    \"\"\"Translates any values into discrete, equidistant values between 0 and 1.\"\"\"\n\n    @store_init_arguments\n    def __init__(self, values: list):\n        \"\"\"\n        Args:\n            values: List of all possible values of (almost) arbitrary type.\n        \"\"\"\n        super().__init__(None, (0, 1))\n        self.values = copy.deepcopy(values)\n\n    def inverse(self, numerical_value: float) -&gt; Any:\n        return self.values[\n            int(\n                np.clip(\n                    np.around(numerical_value * len(self.values) - 0.5),\n                    0,\n                    len(self.values) - 1,\n                )\n            )\n        ]\n\n    def __call__(self, value: Any) -&gt; float:\n        idx = self.values.index(value)\n        return (0.5 + idx) / len(self.values)\n\n    def __eq__(self, other):\n        if len(self.values) != len(other.values):\n            return False\n        for e1, e2 in zip(self.values, other.values):\n            # need to handle some special cases that can occur with categorical values\n            if (e1 is None) and (e2 is None):\n                continue\n            if e1 == e2:\n                continue\n            # == will not yield true, if both values are NAN\n            try:\n                if math.isnan(e1) and math.isnan(e2):\n                    continue\n            except TypeError:\n                pass\n\n            return False\n\n        return True\n</code></pre>"},{"location":"API-Reference/transformations/categorical/#parameterspace.transformations.categorical.Cat2Num.__init__","title":"<code>__init__(self, values)</code>  <code>special</code>","text":"<p>Parameters:</p> Name Type Description Default <code>values</code> <code>list</code> <p>List of all possible values of (almost) arbitrary type.</p> required Source code in <code>parameterspace/transformations/categorical.py</code> <pre><code>@store_init_arguments\ndef __init__(self, values: list):\n    \"\"\"\n    Args:\n        values: List of all possible values of (almost) arbitrary type.\n    \"\"\"\n    super().__init__(None, (0, 1))\n    self.values = copy.deepcopy(values)\n</code></pre>"},{"location":"API-Reference/transformations/categorical/#parameterspace.transformations.categorical.Cat2Num.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>Convert the numerical representation back to the true value with the proper type.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value corresponding to the given value. Type depends no the kind of transformation.</p> Source code in <code>parameterspace/transformations/categorical.py</code> <pre><code>def inverse(self, numerical_value: float) -&gt; Any:\n    return self.values[\n        int(\n            np.clip(\n                np.around(numerical_value * len(self.values) - 0.5),\n                0,\n                len(self.values) - 1,\n            )\n        )\n    ]\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/","title":"Log zero one","text":""},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneFloat","title":"<code> LogZeroOneFloat            (BaseTransformation)         </code>","text":"<p>Maps bounded interval to [0,1] via a logarithmic transformation.</p> <p>This means that all the priors used with a parameter effectively model the exponent of the actual quantity.</p> <p>This class should be used for ContinuousParameters.</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>class LogZeroOneFloat(BaseTransformation):\n    \"\"\"Maps bounded interval to [0,1] via a logarithmic transformation.\n\n    This means that all the priors used with a parameter effectively model the\n    exponent of the actual quantity.\n\n    This class should be used for ContinuousParameters.\n    \"\"\"\n\n    @store_init_arguments\n    def __init__(self, bounds: Optional[Tuple]):\n        \"\"\"\n        [summary]\n\n        Args:\n            bounds: Bounds must be positive for log-transformation.\n        \"\"\"\n        assert min(bounds) &gt; 0, \"bounds must be positive for log-transformation\"\n        super().__init__(bounds, (0, 1))\n        self.log_bounds = np.log(self.input_bounds)\n        self.log_interval_size = self.log_bounds[1] - self.log_bounds[0]\n\n    def inverse(self, numerical_value: float) -&gt; float:\n        return float(\n            np.clip(\n                np.exp(self.log_bounds[0] + numerical_value * (self.log_interval_size)),\n                self.input_bounds[0],\n                self.input_bounds[1],\n            )\n        )\n\n    def __call__(self, value: Any) -&gt; float:\n        return float((np.log(value) - self.log_bounds[0]) / self.log_interval_size)\n\n    def jacobian_factor(self, numerical_value: float) -&gt; float:\n        return 1.0 / (self.log_interval_size * self.inverse(numerical_value))\n\n    def __eq__(self, other):\n        return np.allclose(self.input_bounds, other.input_bounds)\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneFloat.__init__","title":"<code>__init__(self, bounds)</code>  <code>special</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Optional[Tuple]</code> <p>Bounds must be positive for log-transformation.</p> required Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>@store_init_arguments\ndef __init__(self, bounds: Optional[Tuple]):\n    \"\"\"\n    [summary]\n\n    Args:\n        bounds: Bounds must be positive for log-transformation.\n    \"\"\"\n    assert min(bounds) &gt; 0, \"bounds must be positive for log-transformation\"\n    super().__init__(bounds, (0, 1))\n    self.log_bounds = np.log(self.input_bounds)\n    self.log_interval_size = self.log_bounds[1] - self.log_bounds[0]\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneFloat.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>Convert the numerical representation back to the true value with the proper type.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value corresponding to the given value. Type depends no the kind of transformation.</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>def inverse(self, numerical_value: float) -&gt; float:\n    return float(\n        np.clip(\n            np.exp(self.log_bounds[0] + numerical_value * (self.log_interval_size)),\n            self.input_bounds[0],\n            self.input_bounds[1],\n        )\n    )\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneFloat.jacobian_factor","title":"<code>jacobian_factor(self, numerical_value)</code>","text":"<p>Factor to correct the likelihood based on the non-linear transformation.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Jacobian factor to properly transform the likelihood.</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>def jacobian_factor(self, numerical_value: float) -&gt; float:\n    return 1.0 / (self.log_interval_size * self.inverse(numerical_value))\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneInteger","title":"<code> LogZeroOneInteger            (BaseTransformation)         </code>","text":"<p>Maps a bounded interval of integers to [0, 1] via a logarithmic transformation.</p> <p>This means that all the priors used with a parameter effectively model the exponent of the actual quantity.</p> <p>This class should be used for IntegerParameters.</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>class LogZeroOneInteger(BaseTransformation):\n    \"\"\"Maps a bounded interval of integers to [0, 1] via a logarithmic transformation.\n\n    This means that all the priors used with a parameter effectively model the\n    exponent of the actual quantity.\n\n    This class should be used for IntegerParameters.\n    \"\"\"\n\n    @store_init_arguments\n    def __init__(self, bounds: Optional[Tuple]):\n        \"\"\"\n        [summary]\n\n        Args:\n            bounds: Bounds must be positive for log-transformation.\n        \"\"\"\n        assert min(bounds) &gt; 0, \"bounds must be positive for log-transformation\"\n        super().__init__(bounds, (0, 1))\n        self.log_bounds = np.log(self.input_bounds + np.array([-0.5, 0.5]))\n        self.log_interval_size = self.log_bounds[1] - self.log_bounds[0]\n\n    def inverse(self, numerical_value: float) -&gt; int:\n        \"\"\"\n        [summary]\n        \"\"\"\n        integer_value = np.around(\n            np.exp(self.log_bounds[0] + numerical_value * (self.log_interval_size))\n        )\n        # clip result to bound due to rounding problems when the numerical value is 0.0\n        return int(np.clip(integer_value, *self.input_bounds))\n\n    def __call__(self, value: Any) -&gt; float:\n        return float((np.log(value) - self.log_bounds[0]) / self.log_interval_size)\n\n    def jacobian_factor(self, numerical_value: float) -&gt; float:\n        return 1.0 / (self.log_interval_size * self.inverse(numerical_value))\n\n    def __eq__(self, other):\n        return np.allclose(self.input_bounds, other.input_bounds)\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneInteger.__init__","title":"<code>__init__(self, bounds)</code>  <code>special</code>","text":"<p>[summary]</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>Optional[Tuple]</code> <p>Bounds must be positive for log-transformation.</p> required Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>@store_init_arguments\ndef __init__(self, bounds: Optional[Tuple]):\n    \"\"\"\n    [summary]\n\n    Args:\n        bounds: Bounds must be positive for log-transformation.\n    \"\"\"\n    assert min(bounds) &gt; 0, \"bounds must be positive for log-transformation\"\n    super().__init__(bounds, (0, 1))\n    self.log_bounds = np.log(self.input_bounds + np.array([-0.5, 0.5]))\n    self.log_interval_size = self.log_bounds[1] - self.log_bounds[0]\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneInteger.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>[summary]</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>def inverse(self, numerical_value: float) -&gt; int:\n    \"\"\"\n    [summary]\n    \"\"\"\n    integer_value = np.around(\n        np.exp(self.log_bounds[0] + numerical_value * (self.log_interval_size))\n    )\n    # clip result to bound due to rounding problems when the numerical value is 0.0\n    return int(np.clip(integer_value, *self.input_bounds))\n</code></pre>"},{"location":"API-Reference/transformations/log_zero_one/#parameterspace.transformations.log_zero_one.LogZeroOneInteger.jacobian_factor","title":"<code>jacobian_factor(self, numerical_value)</code>","text":"<p>Factor to correct the likelihood based on the non-linear transformation.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Jacobian factor to properly transform the likelihood.</p> Source code in <code>parameterspace/transformations/log_zero_one.py</code> <pre><code>def jacobian_factor(self, numerical_value: float) -&gt; float:\n    return 1.0 / (self.log_interval_size * self.inverse(numerical_value))\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/","title":"Zero one","text":""},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneFloat","title":"<code> ZeroOneFloat            (BaseTransformation)         </code>","text":"<p>Maps a bounded interval to [0, 1] via a linear transformation.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>class ZeroOneFloat(BaseTransformation):\n    \"\"\"Maps a bounded interval to [0, 1] via a linear transformation.\"\"\"\n\n    @store_init_arguments\n    def __init__(self, bounds: Optional[Tuple]):\n        super().__init__(bounds, (0, 1))\n        self.interval_size = bounds[1] - bounds[0]\n\n    def inverse(self, numerical_value: float) -&gt; float:\n        return float(\n            np.clip(\n                self.input_bounds[0] + numerical_value * (self.interval_size),\n                self.input_bounds[0],\n                self.input_bounds[1],\n            )\n        )\n\n    def __call__(self, value: Any) -&gt; float:\n        return float((value - self.input_bounds[0]) / self.interval_size)\n\n    def __eq__(self, other):\n        return np.allclose(self.input_bounds, other.input_bounds)\n\n    def jacobian_factor(self, numerical_value: float) -&gt; float:\n        return 1.0 / self.interval_size\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneFloat.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>Convert the numerical representation back to the true value with the proper type.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The value corresponding to the given value. Type depends no the kind of transformation.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>def inverse(self, numerical_value: float) -&gt; float:\n    return float(\n        np.clip(\n            self.input_bounds[0] + numerical_value * (self.interval_size),\n            self.input_bounds[0],\n            self.input_bounds[1],\n        )\n    )\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneFloat.jacobian_factor","title":"<code>jacobian_factor(self, numerical_value)</code>","text":"<p>Factor to correct the likelihood based on the non-linear transformation.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Jacobian factor to properly transform the likelihood.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>def jacobian_factor(self, numerical_value: float) -&gt; float:\n    return 1.0 / self.interval_size\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneInteger","title":"<code> ZeroOneInteger            (BaseTransformation)         </code>","text":"<p>Maps a bounded interval of integers to [0, 1] via a linear transformation.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>class ZeroOneInteger(BaseTransformation):\n    \"\"\"Maps a bounded interval of integers to [0, 1] via a linear transformation.\"\"\"\n\n    @store_init_arguments\n    def __init__(self, bounds: Optional[Tuple]):\n        super().__init__(bounds, (0, 1))\n        self.interval_size = bounds[1] - bounds[0] + 1\n\n    def inverse(self, numerical_value: float) -&gt; int:\n        return int(\n            np.clip(\n                np.around(\n                    self.input_bounds[0] - 0.5 + numerical_value * (self.interval_size)\n                ),\n                self.input_bounds[0],\n                self.input_bounds[1],\n            )\n        )\n\n    def __call__(self, value: Any) -&gt; float:\n        return float((value - self.input_bounds[0] + 0.5) / self.interval_size)\n\n    def __eq__(self, other):\n        return np.allclose(self.input_bounds, other.input_bounds)\n\n    def jacobian_factor(self, numerical_value: float) -&gt; float:\n        return 1.0 / self.interval_size\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneInteger.inverse","title":"<code>inverse(self, numerical_value)</code>","text":"<p>Convert the numerical representation back to the true value with the proper type.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The value corresponding to the given value. Type depends no the kind of transformation.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>def inverse(self, numerical_value: float) -&gt; int:\n    return int(\n        np.clip(\n            np.around(\n                self.input_bounds[0] - 0.5 + numerical_value * (self.interval_size)\n            ),\n            self.input_bounds[0],\n            self.input_bounds[1],\n        )\n    )\n</code></pre>"},{"location":"API-Reference/transformations/zero_one/#parameterspace.transformations.zero_one.ZeroOneInteger.jacobian_factor","title":"<code>jacobian_factor(self, numerical_value)</code>","text":"<p>Factor to correct the likelihood based on the non-linear transformation.</p> <p>Parameters:</p> Name Type Description Default <code>numerical_value</code> <code>float</code> <p>Transformed/Numerical representation of a value.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Jacobian factor to properly transform the likelihood.</p> Source code in <code>parameterspace/transformations/zero_one.py</code> <pre><code>def jacobian_factor(self, numerical_value: float) -&gt; float:\n    return 1.0 / self.interval_size\n</code></pre>"},{"location":"notebooks/example_1/","title":"Different parameter types","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport parameterspace\n</pre> import numpy as np import matplotlib.pyplot as plt import parameterspace In\u00a0[\u00a0]: Copied! <pre>f1 = parameterspace.ContinuousParameter(name='f1', bounds=[-5., 5.])\nprint(f1)\n</pre> f1 = parameterspace.ContinuousParameter(name='f1', bounds=[-5., 5.]) print(f1) <p>Now let't draw some samples from it:</p> In\u00a0[\u00a0]: Copied! <pre>print(\"Samples: \", f1.sample_values(5))\n</pre> print(\"Samples: \", f1.sample_values(5)) <p>Every parameter can compute the loglikelihood of a given value (that depends on the prior, but more on that later).</p> In\u00a0[\u00a0]: Copied! <pre>def likelihood_plots(parameter, num_samples=1024, cdf_plot=True):\n    xs = np.linspace(parameter.bounds[0]-1, parameter.bounds[1]+1, 256)\n    likelihoods = np.exp([parameter.loglikelihood(x) for x in xs])\n    plt.plot(xs, likelihoods)\n    plt.title('prior likelihood')\n    plt.xlabel(r'$%s$'%parameter.name)\n    plt.ylabel('pdf')\n    plt.show()\n\n    plt.hist(parameter.sample_values(num_samples=num_samples), density=True)\n    plt.title('empirical PDF based on sampled values')\n    plt.show()\n\n    if cdf_plot:\n        plt.hist(parameter.sample_values(num_samples=num_samples), density=True, cumulative=True, bins=64)\n        plt.title('empirical CDF based on sampled values')\n        plt.show()\n\n    \nlikelihood_plots(f1)\n</pre> def likelihood_plots(parameter, num_samples=1024, cdf_plot=True):     xs = np.linspace(parameter.bounds[0]-1, parameter.bounds[1]+1, 256)     likelihoods = np.exp([parameter.loglikelihood(x) for x in xs])     plt.plot(xs, likelihoods)     plt.title('prior likelihood')     plt.xlabel(r'$%s$'%parameter.name)     plt.ylabel('pdf')     plt.show()      plt.hist(parameter.sample_values(num_samples=num_samples), density=True)     plt.title('empirical PDF based on sampled values')     plt.show()      if cdf_plot:         plt.hist(parameter.sample_values(num_samples=num_samples), density=True, cumulative=True, bins=64)         plt.title('empirical CDF based on sampled values')         plt.show()       likelihood_plots(f1) In\u00a0[\u00a0]: Copied! <pre>f2_prior = parameterspace.priors.TruncatedNormal(mean=.5, std=.25)\n\nf2 = parameterspace.ContinuousParameter(name='f_1', bounds=[-5., 5.], prior=f2_prior)\nprint(f2)\n\nlikelihood_plots(f2)\n</pre> f2_prior = parameterspace.priors.TruncatedNormal(mean=.5, std=.25)  f2 = parameterspace.ContinuousParameter(name='f_1', bounds=[-5., 5.], prior=f2_prior) print(f2)  likelihood_plots(f2) In\u00a0[\u00a0]: Copied! <pre>bounds = [-3, 5]\n\ni1_prior = parameterspace.priors.Beta(a=2, b=0.5)\ni1 = parameterspace.ContinuousParameter(name='i_1', bounds=bounds, prior=i1_prior)\n\nprint('Samples: ', i1.sample_values(5))\nlikelihood_plots(i1)\n</pre> bounds = [-3, 5]  i1_prior = parameterspace.priors.Beta(a=2, b=0.5) i1 = parameterspace.ContinuousParameter(name='i_1', bounds=bounds, prior=i1_prior)  print('Samples: ', i1.sample_values(5)) likelihood_plots(i1) In\u00a0[\u00a0]: Copied! <pre>bounds = [1, 256]\ni2 = parameterspace.IntegerParameter(name='i_2', bounds=bounds, transformation='log')\nprint('Samples: ', i2.sample_values(32))\nlikelihood_plots(i2)\n</pre> bounds = [1, 256] i2 = parameterspace.IntegerParameter(name='i_2', bounds=bounds, transformation='log') print('Samples: ', i2.sample_values(32)) likelihood_plots(i2) In\u00a0[\u00a0]: Copied! <pre>values = ['foo', 'bar', 42, np.pi]\nc1_prior = [3, 1, 1, 1.5]\n\nc1 = parameterspace.CategoricalParameter(name='c_1', values=values, prior=c1_prior)\nprint(c1)\n\nprint('Samples: ', c1.sample_values(num_samples=10))\n\nplt.bar([0,1,2,3], np.exp([c1.loglikelihood(value) for value in values]))\nplt.xticks([0,1,2,3], values)\nplt.title('prior likelihood')\nplt.xlabel(r'$%s$'%c1.name)\nplt.ylabel('pdf')\nplt.show()\n\nc1.sample_values(num_samples=100)\n</pre> values = ['foo', 'bar', 42, np.pi] c1_prior = [3, 1, 1, 1.5]  c1 = parameterspace.CategoricalParameter(name='c_1', values=values, prior=c1_prior) print(c1)  print('Samples: ', c1.sample_values(num_samples=10))  plt.bar([0,1,2,3], np.exp([c1.loglikelihood(value) for value in values])) plt.xticks([0,1,2,3], values) plt.title('prior likelihood') plt.xlabel(r'$%s$'%c1.name) plt.ylabel('pdf') plt.show()  c1.sample_values(num_samples=100)"},{"location":"notebooks/example_1/#different-parameter-types","title":"Different parameter types\u00b6","text":"<p>This notebook simply demonstrates the different parameter types and gives an idea of the functionality.</p> <p>Copyright (c) 2021 - for information on the respective copyright owner see the NOTICE file and/or the repository https://github.com/boschresearch/parameterspace</p> <p>SPDX-License-Identifier: Apache-2.0</p>"},{"location":"notebooks/example_1/#a-simple-continuous-parameter","title":"A simple continuous parameter\u00b6","text":"<p>Let's first create a continuous parameter defined in the interval [-5, 5] and print out some information</p>"},{"location":"notebooks/example_1/#defining-a-prior","title":"Defining a prior\u00b6","text":"<p>To make things more useful, every parameter has a prior associated to it. The default is a uninformed prior ( aka a uniform distribution), but other more interesting ones are already there, namely:</p> <ul> <li>the trucated normal distribution</li> <li>the Beta distribution</li> <li>a categorical distribution</li> </ul> <p>Because the numerical representation of the parameters is mapped into the unit hypecube, all priors must be defined in the transformed range. As an example, let us consider a truncated normal prior for a continuous parameter in the interval $[-5, 5]$. If we want to place a prior with mean 0 and a standard deviation of $2.5$, we would use a TruncatedNormal with</p> <ul> <li>$mean=0.5$, because the interval is mapped linearly onto $[0,1]$, i.e. the original value of $0$ is mapped to $0.5$</li> <li>$std=0.25$, because the original interval has a width of $10$, and $2.5$ is a quater of that. Therefore, the mapped standard deviation must be a quater of the mapped inteval length, which is one.</li> </ul>"},{"location":"notebooks/example_1/#beta-prior","title":"Beta Prior\u00b6","text":"<p>Here is another exapmle using a Beta prior in the transformed space</p>"},{"location":"notebooks/example_1/#categorical-parameters-are-also-supported","title":"Categorical parameters are also supported\u00b6","text":"<p>Categorical parameters do not have an intrinsic ordering, so the only meaningful prior defines the probability for each value. The values can be of 'any type' even mixing types is possible.</p>"},{"location":"notebooks/example_2_simple_parameterspace/","title":"A simple parameter space consisting of two continuous parameters","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport parameterspace\n</pre> import numpy as np import matplotlib.pyplot as plt import parameterspace <p>Here, we actually instantiate the parameters and add them to the space</p> In\u00a0[\u00a0]: Copied! <pre>f1_prior = parameterspace.priors.Beta(a=2, b=1)\nf2_prior = parameterspace.priors.TruncatedNormal(mean=0.8, std=.3)\n\nf1 = parameterspace.ContinuousParameter(name='f_1', bounds=[0., 1.], prior=f1_prior)\nf2 = parameterspace.ContinuousParameter(name='f_2', bounds=[-5., 5.], prior=f2_prior)\n\ns = parameterspace.ParameterSpace()\ns.add(f1)\ns.add(f2)\n\nprint(s)\n</pre> f1_prior = parameterspace.priors.Beta(a=2, b=1) f2_prior = parameterspace.priors.TruncatedNormal(mean=0.8, std=.3)  f1 = parameterspace.ContinuousParameter(name='f_1', bounds=[0., 1.], prior=f1_prior) f2 = parameterspace.ContinuousParameter(name='f_2', bounds=[-5., 5.], prior=f2_prior)  s = parameterspace.ParameterSpace() s.add(f1) s.add(f2)  print(s) <p>The space can also produce samples, but (for now) only one sample at a time! The method <code>to_numerical</code> converts a configuration (which is a dictionary) into a numpy array. Let's draw some samples and plot the loglikelihood for this 2d space. Note that the ranges are [0,1] for both dimensions, because we plot everything in the transformed domain. We only do this here for simplicity, because working with the true values would require logic with dictionaries rather than numpy arrays, which are simpler here.</p> In\u00a0[\u00a0]: Copied! <pre>samples = np.array([s.to_numerical(s.sample()) for i in range(256)])\n\n\nX,Y = np.meshgrid(np.linspace(0,1, 32, endpoint=True), np.linspace(0, 1, 32, endpoint=True))\nll =np.array([s.log_likelihood_numerical([x,y]) for x,y in zip(X.flatten(), Y.flatten())]).reshape(X.shape)\n\nfig, ax = plt.subplots()\n\ncs = ax.contourf(X,Y, ll)\nax.scatter(samples[:,0], samples[:,1])\nfig.colorbar(cs)\nplt.show()\n</pre> samples = np.array([s.to_numerical(s.sample()) for i in range(256)])   X,Y = np.meshgrid(np.linspace(0,1, 32, endpoint=True), np.linspace(0, 1, 32, endpoint=True)) ll =np.array([s.log_likelihood_numerical([x,y]) for x,y in zip(X.flatten(), Y.flatten())]).reshape(X.shape)  fig, ax = plt.subplots()  cs = ax.contourf(X,Y, ll) ax.scatter(samples[:,0], samples[:,1]) fig.colorbar(cs) plt.show()"},{"location":"notebooks/example_2_simple_parameterspace/#a-simple-parameter-space-consisting-of-two-continuous-parameters","title":"A simple parameter space consisting of two continuous parameters\u00b6","text":"<p>Copyright (c) 2021 - for information on the respective copyright owner see the NOTICE file and/or the repository https://github.com/boschresearch/parameterspace</p> <p>SPDX-License-Identifier: Apache-2.0</p>"},{"location":"notebooks/example_3_conditional_spaces/","title":"A conditional (hence more interesting) search space","text":"In\u00a0[\u00a0]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport parameterspace as ps\n</pre> import numpy as np import matplotlib.pyplot as plt import parameterspace as ps <p>As an example, consider optimizing the training parameters for a a neural network, namely which optimizer to use, and the parameters for each of them. The two optimizers are 'Adam' and 'SGD' with a learning rate each and a an additional momentum term for SGD.</p> In\u00a0[\u00a0]: Copied! <pre>optimizer = ps.CategoricalParameter('optimizer', ['ADAM', 'SGD'])\n\nlr_adam = ps.ContinuousParameter('lr_adam', bounds=[1e-5, 1e-3], \n                                transformation='log')\n\nlr_sgd = ps.ContinuousParameter('lr_sgd', bounds=[1e-3, 1e-0], prior=ps.priors.TruncatedNormal(mean=0.5, std=0.2))\n\nmomentum_sgd = ps.ContinuousParameter('momentum', bounds=[0, 0.9])\n</pre> optimizer = ps.CategoricalParameter('optimizer', ['ADAM', 'SGD'])  lr_adam = ps.ContinuousParameter('lr_adam', bounds=[1e-5, 1e-3],                                  transformation='log')  lr_sgd = ps.ContinuousParameter('lr_sgd', bounds=[1e-3, 1e-0], prior=ps.priors.TruncatedNormal(mean=0.5, std=0.2))  momentum_sgd = ps.ContinuousParameter('momentum', bounds=[0, 0.9]) <p>Now, we can create the space containing the parameters. The condition argument must be a callable that has its argument names be parameter names and returns True if the parameter should be active and False otherwise.</p> In\u00a0[\u00a0]: Copied! <pre>s = ps.ParameterSpace()\n\ns.add(optimizer)\ns.add(lr_adam,      condition=lambda optimizer: optimizer=='ADAM')\ns.add(lr_sgd,       condition=lambda optimizer: optimizer=='SGD')\ns.add(momentum_sgd, condition=lambda optimizer: optimizer=='SGD')\n\nprint(s)\n</pre> s = ps.ParameterSpace()  s.add(optimizer) s.add(lr_adam,      condition=lambda optimizer: optimizer=='ADAM') s.add(lr_sgd,       condition=lambda optimizer: optimizer=='SGD') s.add(momentum_sgd, condition=lambda optimizer: optimizer=='SGD')  print(s) <p>Now we can draw samples:</p> In\u00a0[\u00a0]: Copied! <pre>for i in range(5):\n    print(s.sample())\n</pre> for i in range(5):     print(s.sample()) <p>If you are interested in random samples of a subspace, you can also give a partial assignment to the sample method to set those parameters manually. Here are some samples with <code>ADAM</code> as the optimizer:</p> In\u00a0[\u00a0]: Copied! <pre>for i in range(5):\n    print(s.sample({'optimizer': 'ADAM'}))\n</pre> for i in range(5):     print(s.sample({'optimizer': 'ADAM'})) <p>and here some with <code>SGD</code> as the optimizer:</p> In\u00a0[\u00a0]: Copied! <pre>for i in range(5):\n    print(s.sample({'optimizer': 'SGD'}))\n</pre> for i in range(5):     print(s.sample({'optimizer': 'SGD'})) <p>When working with these spaces, a purely numerical represetation can be accessed via the <code>to_numerical</code> method. Note that these values are in the transformed space and might contain special values (nan by default) for inactive values.</p> In\u00a0[\u00a0]: Copied! <pre>sample = s.sample()\nprint(sample)\ns.to_numerical(sample)\n</pre> sample = s.sample() print(sample) s.to_numerical(sample)"},{"location":"notebooks/example_3_conditional_spaces/#a-conditional-hence-more-interesting-search-space","title":"A conditional (hence more interesting) search space\u00b6","text":"<p>Copyright (c) 2021 - for information on the respective copyright owner see the NOTICE file and/or the repository https://github.com/boschresearch/parameterspace</p> <p>SPDX-License-Identifier: Apache-2.0</p>"}]}